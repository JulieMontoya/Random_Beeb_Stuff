# AN EXPERIMENTAL PROGRAMMING LANGUAGE RUNTIME

Just trying to see whether I can do enough with bits of YSON and BCP to
create a runtime library capable of supporting a cut-down BBC BASIC.

# THE RATIONALE

YSON compiles directly to 6502 assembly code.  It is still quite limited;
only 8-bit arithmetic is possible, only one level of nested `FOR` loop
is supported, strings are non-existent and variables work in a somewhat
unorthodox way in order to be directly compatible with the AdveBuilder
game engine.

Here the intention is to create something which works a bit more like BBC
BASIC and should be able to compile existing programs with minimal changes.
For speed, 16-bit integer arithmetic is used throughout.

Instead of compiling directly to 6502 code, it generates an intermediate
code, which I am going to call **J-CODE**, and which will be interpreted
by a virtual machine.  This probably will be slower than native, threaded
code, but should still be faster than interpreting the BASIC source code
directly.  The slow parts will be taken care of in the compilation step;
translating variable names to addresses, parsing expressions and ordering
operations by priority, and so forth.  J-CODE will be as streamlined as
possible, and everything in BASIC will have a direct equivalent in J-CODE.

A BASIC instruction such as
```
SOUND C%,-15,P%*4+48,L%
```
would translate to the following J-CODE:
```
use (&040C)     ; location of C% => channel
use &FFF1       ; => loudness
use (&0440)     ; location of P%
mul &0004       ; multiply it by 4
add &0030       ; add 48 => pitch
use (&0430)     ; location of L% => length
snd             ; = SOUND in BASIC
```
The `snd` instruction works exactly like the `SOUND` command in BASIC,
which just makes a call to OSWORD and lets the MOS take care of making
the actual sound.

Not every J-CODE instruction will necessarily have a BASIC equivalent, for
the sake of generality of purpose, extensibility and portability.  (It's
definitely feasible to build a 6502-based microcomputer on a collection of
prototyping breadboards, for instance .....)


## SYMBOLISER

The **symboliser** generates a symbol table giving the name of each variable
used in the program and their locations in memory.

## TRANSLATOR

The **translator** combines the BASIC source code in memory with a symbol
table generated by the symboliser, to produce an equivalent J-CODE program.

## RUNTIME

The **runtime** actually interprets the J-CODE program. 

# THE SYMBOL TABLE

The symbol table is created by the Symboliser.  It is a database of variable
names and their locations in memory.  Unlike the one created by BBC BASIC,
the TinyBASIC symbol table is searched linearly; this will only ever need to
be done at the time of compilation.  The compiled code will refer to
variables directly by their locations in memory.

### VARIABLES

The **variables** portion of the symbol table is a database of all variable
names used in the program, and their locations in memory.  It is simpler
than the equivalent generated by BBC BASIC.  This will make searching it
slower; _but_ the database only ever needs to be searched at the translation
stage.  The J-CODE refers to variables directly by their location in memory.

### PROCEDURES

The **procedures** portion of the symbol table is a database of all
`PROC`edure names, entry points and parameter blocks.

A procedure parameter block contains the locations of each parameter and
all variables declared `LOCAL` to the procedure.  On entry to the
`PROC`edure, the values of those variables are stored on the Stack, and the
variables declared as parameters are populated with values taken from lower
down the Stack.  (The parameter block can always be re-read, so the
locations need not be stored on the Stack.)  On exit, the local variables
and variables used for parameters are restored from the Stack, and the Stack
pointer reset to wherever it was before the first of the parameters was
pushed to the Stack.

### FUNCTIONS

A **function** works similarly to a procedure, except that it returns a
value on the Stack.

Function parameter blocks are otherwise the same as procedure parameter
blocks.

Byte | Size | Meaning
-----|------|---------------------------------
0    |    1 | Number of parameters
1    |    1 | Number of local variables
2    |    1 | 0 for a PROC, 1 for a FN
3-4  |    2 | Address of 1st parameter
5-6  |    2 | Address of 2nd parameter
...  |  ... | ...
.    |    2 | Address of last parameter
.    |    2 | Address of 1st local variable
.    |    2 | Address of 2nd local variable
...  |  ... | ...
.    |    2 | Address of last local variable
.    |    2 | Address of code


# THE VIRTUAL MACHINE

The virtual machine is primarily stack-based.  A few registers are used
internally.

The virtual machine is based primarily around a stack, which is implemented
in software independently of the 6502 stack.  (_A hypothetical J-code virtual
machine running on the Z-80 probably would use the SP' alternative stack
pointer._)

The virtual machine is based primarily around a stack, which is implemented
in software independently of the 6502 stack.  Program instructions can place
data on the stack and manipulate data already on the stack.


The general principle is to have a virtual machine executing instructions
in an intermediate language, with operands being supplied and results
returned via a stack.  All values are 16-bit signed integers.

An expression such as `2+3` could be represented as follows:
```
use 2
use 3
add
```
**use** is an instruction which places a value on the Stack.  So after
`use 2` the Stack contains the value 2.  After `use 3` the Stack contains
the values 3 and 2.  **add** adds two numbers from the Stack and places
their sum on the Stack.  After `add` the Stack contains the value 5.

We can also read values from memory by placing addresses on the Stack and
executing a **get** instruction, which replaces the value on the Stack by
the contents of that address in memory.  An expression such as
`I% * 100 + V%`
could be represented as follows:
```
use &0414
get
use 100
mul
use &0454
get
add
```

We can do better than this, though, by combining some of the most frequently
occurring operations with a **use** instruction; effectively creating
addressing modes.  This will consume space among the possible instructions,
but if necessary we can limit everything to a subset of the most common ones.


### IMMMEDIATE MODE

Immediate mode takes a value specified in the instruction, pushes it onto the
Stack and performs the specified operation.

Immediate mode is indicated by the presence of an operand: `add 3`

### INDIRECT MODE

Indirect mode takes a value specified in the instruction, pushes it onto
the stack, performs a **get** instruction to get the value stored in that
address and finally performs the specified operation.

Indirect mode is indicated by round brackets: `add (&0454)`

### STACK MODE

This is the normal working mode, which expects any input value(s) on the Stack 
and leaves any result(s) there.

Stack mode instructions do not include an operand: `mul`

.........!.........!.........!.........!.........!.........!.........!.........!

# THE INTERNAL ARCHITECTURE

The internal architecture does not perform immediate and indirect mode
operations exactly as described above.  Rather, some time-saving optimisations
are employed in order to create _the same final result_ as described, in fewer
clock cycles by avoiding shunting values onto and off the stack unnecessarily
and instead transferring them to and from the virtual machine's registers
directly.

## THE W REGISTER

**W** is the Working register, and to all intents and purposes is the top of
the Stack.  Monadic  (single-ended)  operations such as **twc**  (twos
complement)  in stack mode simply replace the value in W with the result of
the operation.  Such operations in immediate and indirect modes store the
current contents of W on the Stack before copying the input value into W, then
perform the operation.

## THE X REGISTER

**X** is the eXtension register.  In **mul**tiply instructions, it can hold a
preload value which will be added to the product; afterwards, it contains the
high bits of the product.  In **div**ide and related instructions, it can
hold the high bits of a 32-bit dividend; it is always cleared before a normal
16-bit division. Afterwards, it will contain the remainder.  The **mod**
instruction performs a division, but copies X back into W afterwards.  

## THE O REGISTER

**O** is the Operand register, and is used for the right-hand operand in
dyadic  (double-ended)  operations.

Operations such as `add` in Immediate and indirect modes import values
directly into the O register, bypassing the Stack.

## THE STACK

The Stack is implemented in software independently of the 6502 stack.  The
W register is the top of the stack.  When a new value is placed on the Stack
with a `use` instruction, the current contents of W are stored on the actual
Stack and then the value is placed in W.  

## ADDRESSING MODES

Instructions which are available in multiple addressing modes are handled by
common routines for the operation type  (dyadic or monadic)  which set up the
virtual machine registers from the Stack or memory as appropriate, despatch
to a specific subroutine for the core operation and alter the Stack pointer
as necessary before returning.

.........!.........!.........!.........!.........!.........!.........!.........!


# CALCULATION STACK

The calculation Stack is independent of the 6502 stack.  The right-hand
operand is read from the Stack or supplied in immediate mode.  The left-hand
operand (if any) is read from the Stack.  On completion of an operation,
the answer is always left on the top of the Stack.

Unless explicitly stated otherwise, all values are signed two-byte numbers,
presented units-first.

# INTERMEDIATE CODE

An intermediate code or **J_CODE** is used to express operations.

# INSTRUCTIONS

Instructions are read and parsed by a despatcher.

.........!.........!.........!.........!.........!.........!.........!.........!

## ADDRESSING MODES

J-code instructions, like 6502 instructions, may exist in several different
addressing modes.  Not all instructions may be sensible in all addressing
modes!

Instructions may pull data from the Stack and/or leave results on the Stack.

Most instructions are available in **Stack mode**, where all operands to be
processed are already on the Stack.

The most common form of instruction takes one operand and acts upon the value
on top of the Stack, placing the result on the Stack.  **Immediate mode** and
**indirect mode** instructions specify the operand itself, or the location
where it is to be found, respectively, within the instruction.

### IMMEDIATE MODE

Instructions in immediate mode include the operand directly within the
instruction.

### INDIRECT MODE

Instructions in indirect mode include an address within the instruction,
where the actual operand may be found.

### STACK MODE

Instructions in Stack mode work on data already on the Stack.


### IMMEDIATE MODE

Instructions in immediate mode include some data.  Some instructions have
the ability to work in a "true" immediate mode using the data from the
instruction directly without storing it on the Stack.  Other instructions
work by copying the data from the instruction to the Stack.

### INDIRECT MODE

Instructions in indirect mode include an address where the actual data
may be found.


.........!.........!.........!.........!.........!.........!.........!.........!

A `SOUND` command takes four parameters: channel, loudness, pitch and length.
These are pushed onto the Stack in order.  The command reads the parameters
in the same order as they were written, rather than pulling them individually
and reversing the order; stores them in a parameter block; and calls `OSWORD`
to play the sound.

# SUBROUTINES

### init_calc_stk

Initialise the calculation Stack.

### pushAX

Push a 16-bit value from A (low byte) and X (high byte) to the calculation
Stack.

### push16

Push a 16-bit value from a zero-page location specified in X to the
calculation Stack.

### pull16

Pull a 16-bit value from the calculation Stack to a zero-page location
specified in X.

### get_both

Pull both left-hand and right-hand operands from the calculation Stack to
their usual zero-page locations.

.get_lho

### .mult_stk

Multiply two numbers at the top of the Stack and place the product on the
Stack.

### disp_dec_stk

Pull a value from the top of the Stack and display it as a decimal number.

### conv_str_stk

Pull an address from the top of the Stack.  Pull a value from the top of
the Stack, and store its decimal representation as an ASCII string, ending
with CR, at the supplied address.

### decode_dec_stk

Pull a value from the top of the Stack.  If it is negative, set bit 7 of
`neg_flag` and twos-complement it.  Repeatedly divide by ten and store the
ASCII value of the digit representing the remainder in a scratch space at
the far end of the calculation Stack, units-first.  On exit, X points to
the location _after_ the last (= first!) digit.

### parse_num_stk

Pull an address from the top of the Stack, move it to `str_ptr` and proceed
to `parse_num_at_ptr`.

### parse_num_at_ptr

Search forwards in memory from `str_ptr` for a decimal number, stopping at
the first non-digit, non-space character.  Return the number read on top
of the Stack.

### store_word

Pull an address from the Stack.  Pull a value from the Stack and store it
in the given address.

### twc16

Replace the value on top of the Stack by its twos complement.

## INTERNAL OPERATIONS

The multiply and divide subroutines are very similar; effectively mutual
inverses.  For speed, they operate on fixed zero-page locations.

Since a 16-bit number multiplied by a 16-bit number gives a 32-bit number,
the product and dividend can actually be 32 bits long.  The locations used
for the high bits serve double duty as a preload register when multiplying
and a remainder when dividing, so there are entry points which bypass the
initial zeroing of these locations when desired.

Location | Meaning (multiplying)     | Meaning (dividing)
---------|---------------------------|----------------------------
&70-&71  | (before) Multiplier (LHO) | (before) Dividend (LHO)
&72-&73  | (before) Preload          | (before) Dividend Extension
&74-&75  | Multiplicand (RHO)        | Divisor (RHO)
&70-&71  | (after) Product           | (after) Quotient
&72-&73  | (after) Product Extension | (after) Remainder

Multiplication is inherently signed-friendly.  Division will need to be
fixed to work with signed values.

Other arithmetic operations can usefully use the same locations for
analogous purposes.

### mult16

Multiply the left-hand operand by the right-hand operand.

### mult16_preload

Multiply the left-hand operand by the right-hand operand and add the value
in the preload to the product.

### set_divisor / set_multiplicand

Store an 8-bit value in the right-hand operand, padding with zeros.

### div16 / divide_no_rem

Divides the left-hand operand by the right-hand operand.

### divide_signed

Divides the 32-bit value in the left-hand operand and extension by the
right-hand operand.  Both operands are first positivified and `neg_flag`
bits are set as follows: Bit 7 indicates that the quotient is really
negative, and bit 6 indicates that the remainder is negative.

# ZERO PAGE WORKSPACE

Location | Name       | Meaning
--------:|------------|-------------------------------------------------
&70-&71  | lh_operand | Left-hand operand / result
&72-&73  | remainder  | Preload / remainder /result extension
&74-&75  | rh_operand | Right-hand operand
&7E      | calc_sp    | Calculation Stack pointer
&7F      | neg_flag   | Negative flag
&80-&81  | code_ptr   | Pointer to instruction being executed
&82-&83  | str_ptr    | String pointer
&84-&85  | loop_ptr   | Pointer to FOR / REPEAT structure in loop stack

# INTERNAL OPCODES

Hex | Opcode | Hex | Opcode | Meaning
----|--------|-----|--------|--------------------------------------
&00 | RTS    | &80 | RTS    | RTS
&01 | DUP    | &81 | USE    | Duplicate TOS or use immediate value
&02 | RDW    | &82 | RDW    | Read word = BASIC ! operator
&03 | WRW    | &83 | WRW    | Write word = BASIC ! operator
&04 | PRN    | &84 | PRN    | Print Number
&05 | VDU    | &85 | VDU    | Display char = VDU
&06 | VDW    | &86 | VDW    | Display 2 chars = VDU Z%;
&07 | MUL    | &87 | MUL    | Multiply = * operator
&08 | DIV    | &88 | DIV    | Divide = / and DIV operators
&09 | MOD    | &89 | MOD    | Modulus = MOD operator
&0A | ADD    | &8A | ADD    | Add = + operator
&0B | SUB    | &8B | SUB    | Subtract = - operator
& |     | & |     | 

# NUMERIC VARIABLES

Numeric variables are 16-bit signed integers.

# ARRAYS

Arrays can have as many dimensions as space permits.

.........!.........!.........!.........!.........!.........!.........!.........!
`DIM S(320)` -- creates a one-dimensional array with 320 entries, accessed
as `S(0)` to `S(319)`.

`DIM B(8,8)` -- creates a two-dimensional array with 64 entries, accessed as
`B(0,0)` to `B(7,7)`.

Subscripts start from 0 and wrap around, so in the above example `S(320)` is
an alias for `S(0)`; `S{318)`and `S(-2)` refer to the same  (last but one)
element, and so on.   **This behaviour differs from BBC BASIC.**  You will
have to increase your dimensions by one if you want to use element 0.

Each array has a header record as follows:

BYTES    | MEANING
---------|----------------------
0        | Number of dimensions
1..2     | First dimension
...      | ...
2n-1..2n | Last dimension

This is followed by the actual data, 2 bytes per element.

## ARRAY BOUNDS ENFORCEMENT

Array bounds are enforced in the most primitive and brutal way possible, by
reducing each subscript modulo the size of its dimension.  If the remainder
is negative, then the size is added  (which is certain to give a positive
answer by the operation of the modulus function).


Mnemonic | Stack | Immed | Indir | Meaning
---------|-------|-------|-------|--------------------------------------
use      | no    | yes   | yes   | Push value on top of Stack.
ovw      | no    | yes   | yes   | Overwrite top of Stack with value.
dup      | yes   | no    | no    | Duplicate value on top of Stack
frg      | yes   | no    | no    | Forget value on top of Stack

# FOR-NEXT LOOPS

BASIC-style `FOR`-`NEXT` loops are supported natively by the J-code
interpreter.  A separate stack is used, with its own pointer, to keep track
of the state of loops; this will limit the maximum depth of nesting.

The `for` instruction, which corresponds directly to `FOR` in BBC BASIC,
expects the following values on the Stack:
```
TOP -> Step size  (after STEP; compiler must insert 1 or -1 if needed)
       Terminating value  (after TO)
       Initial value  (between = and TO)
       Address of control variable
```
This causes the control variable to be initialised, and an entry to be made
on the `for` stack as follows:

Bytes | Meaning
------|-----------------------------
0-1   | Address of control variable
2-3   | Step
4-5   | Terminating value
6-7   | Continue address

The "continue address" is the address of the instruction following the `for`
(the code pointer should be pointing here already).

The `nxt` instruction corresponds to `NEXT` in BBC BASIC, and can behave in
two ways determined by the addressing mode used.

In Stack mode, `nxt` looks at the last entry on the `for` stack.  This
corresponds to `NEXT` on its own without a control variable.  The step is
added to the current value, and the new value compared with the terminating
value.  If the step is positive, and the new value is less than or equal to
the terminating value, the loop repeats from the continue address.  If the
step is negative, and the new value is greater than or equal to the
terminating value, the loop repeats likewise.  If the new value is beyond
the terminating value in the appropriate direction, the loop has finished
and the `for` stack pointer is adjusted accordingly.

In immediate mode, an operand is expected, which gives the address of the
loop control variable.  This corresponds to `NEXT pass%` or similar.  The
`for` stack will be searched for the corresponding loop entry, which will
become the new top of the `for` stack: anything above it will be discarded.
This allows misuse, but is faithful to BBC BASIC's `FOR` implementation.

.........!.........!.........!.........!.........!.........!.........!.........!

# STACK MANIPULATION OPERATIONS

Sometimes, entries on the Stack are not in the exact order they really need
to be.  Therefore, instructions have been provided to reverse some entries
on the Stack; and to roll the Stack, by pulling up an entry from some
distance down the Stack to the top and pushing values down into the gap.

These operations have no direct equivalent in BASIC, but they are used
internally within certain BASIC instructions:

+Array accesses reverse the order of the subscripts on the Stack so as to keep the elements in the expected order. 
+The `for` operation rolls the Stack to put its operands into a more convenient order for the `nxt` instruction, when creating a loop control block on the `for` stack.

Therefore, instructions have been provided to access these operations
directly, in case they prove useful for implementing other languages on the
same runtime.


## REVERSE STACK

The `rev` instruction reverses entries on the stack.

In stack mode, the number of entries to be reversed is read from the stack and
the rest of the stack is reversed. 

In immediate mode, the number of entries to be reversed is given as an operand.

## ROLL STACK

The `rls` instruction pulls out a value from somewhere down the Stack and
pushes it onto the top, rolling entries above the gap down into it so the
Stack size is unaltered.

In stack mode, the number of entries to be rolled is read from the stack
first and then the rest of the stack is rolled.

In immediate mode, the number of entries to be rolled is given as an operand.


# DIFFERENCES FROM BBC BASIC

+ All mathematics is 16-bit integer.
+ The `!` memory operator operates on 16-bit values.
+ After `DIM A(10)`, `A(0)` and `A(10)` refer to the _same_ array element!
+ Only strings using the `$` memory operator are supported.

