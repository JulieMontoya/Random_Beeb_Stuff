scr_ptr         = &70   \  Pointer to screen memory
see_ptr         = &72   \  Pointer to vision map
text_ptr        = &74   \  Text pointer for printing

set_ptr         = &76   \  Main set pointer
alt_ptr         = &78   \  Alternate set pointer for 2-way set operations

remainder       = &81   \  For dodgy fast division routine, or scratch
divisor         = &82
quotient        = &80

multiplier      = &80   \  For multiplication routine, or scratch
preload         = &82
multiplicand    = &84
product         = &80

tempX           = &86
tempY           = &87
pixelX          = &88   \  Pixel X co-ordinate 0..77
pixelY          = &89   \  Pixel Y co-ordinate 0..74  (0 is top of screen!)
fix_pos         = &8A   \  Fixed position to which we are comparing cells
var_pos         = &8B   \  Variable position of cell being compared
solved          = &8C   \  Number of solved digits in puzzle so far
digit           = &8D
cand_copy       = &8E   \  Copy of candidates for cell under consideration

\  BASIC VARIABLES

bas_var_S       = &44C

\  MOS ENTRY POINTS

osasci          = &FFE3
osnewl          = &FFE7
oswrch          = &FFEE

\  ERROR CODES

E_NOT_ALLOWED   = 51

\  SEEMS TO BE WORKING NOW
\  WILL COMMENT OUT DEBUGGING CODE FOR NOW RATHER THAN REMOVE IT ALTOGETHER
\  JUST IN CASE .....


ORG &6000

.code_begin

.ext_reset_grid
    JMP reset_grid
.ext_set_digit
    JMP set_digit
.ext_set_pixel
    JMP set_pixel
.ext_clr_pixel
    JMP clr_pixel
.ext_show_seen
    JMP show_seen
.ext_test_solved
    JMP test_solved
.ext_test_candidate
    JMP test_candidate
.ext_eliminate_candidate
    JMP eliminate_candidate
.ext_disp_pos
    JMP disp_pos
.ext_disp_contents
    JMP disp_contents
.ext_get_see
    JMP get_see
.ext_clr_seen
    JMP clr_seen
.ext_elim_out
    JMP elim_out
.ext_reset_tally
    JMP reset_tally
.ext_update_tally
    JMP update_tally
.ext_show_instances
    JMP show_instances
.ext_get_set_cell
    JMP get_set_cell
.ext_set_set_cell
    JMP set_set_cell
.ext_clr_set_cell
    JMP clr_set_cell
.ext_show_set
    JMP show_set
.ext_tally_set
    JMP tally_set
.ext_fill_set
    JMP fill_set
.ext_elim_in
    JMP elim_in
.ext_elim_set
    JMP elim_set
.ext_dump_grid
    JMP dump_grid
.ext_count_solved
    JMP count_solved
.ext_clr_digit
    JMP clr_digit
.ext_write_digit
    JMP write_digit
.ext_init_alt_for_all
    JMP init_alt_for_all
.ext_show_alt
    JMP show_alt
.ext_and_alt_seen
    JMP and_alt_seen
.ext_test_alt
    JMP test_alt
.ext_get_alt_cell
    JMP get_alt_cell
.ext_and_alt_digit
    JMP and_alt_digit
.ext_init_alt_digit
    JMP init_alt_digit
.ext_elim_ext
    JMP elim_ext
.ext_eliminate_all
    JMP eliminate_all
\    .ext_set_pmk
\        JMP set_pmk
\    .ext_clr_pmk
\        JMP clr_pmk
\    .ext_toggle_pmk
\        JMP toggle_pmk
\    .ext_calc_digit_pos
\        JMP calc_digit_pos
\    .ext_calc_pmk_pos
\        JMP calc_pmk_pos
\    .ext_divide_by_3
\        JMP divide_by_3
\    .ext_multiply
\        JMP mult16
\    .ext_set_digit_colour
\        JMP set_digit_colour
\    .ext_set_see
\        JMP set_see
\    .ext_clr_see
\        JMP clr_see
\    .ext_calc_see_pos
\        JMP calc_see_pos
    
.divide_by_3
    LDY #&C0
    STY divisor
.fast_divide
    LDY #0
    STY quotient
.fd1
    TAY                 \  Save remainder in Y
    SEC
    SBC divisor
    BCS fd2             \  Skip restore if subtraction succeeded
    TYA                 \  Undo subtraction
.fd2
    ROL quotient        \  Shift in carry bit
    LSR divisor         \  Try subtracting in next lower place
    BCC fd1             \  Keep going till 1 drops out of the end
    TAY                 \  Return remainder in Y
    LDA quotient
    RTS
    
.mult16
    LDA #0
    STA product+3
    STA product+2
.mult16_preload
    \  Begin by shifting the multiplier right so its lowest bit is already
    \  in the carry flag.
    LDY #17             \  one more than we need
    BNE _mult16_3      \  always branches; A = 0
._mult16_1
    BCC _mult16_2
    \  Add the multiplicand to the high word of the product
    CLC
    LDA product+2
    ADC multiplicand
    STA product+2
    LDA product+3
    ADC multiplicand+1
    STA product+3
    \  Shift the product right
._mult16_2
    ROR product+3
    ROR product+2
._mult16_3
    ROR product+1
    ROR product
    \  See if we need to go around again
    DEY
    BNE _mult16_1
    RTS
    
.set_mulcnd
    STA multiplicand
    LDA #0
    STA multiplicand+1
    RTS
    
.alt_calc_see_pos
    STX preload
    STY multiplier
    LDA #81
    STA multiplicand
    LDA #0
    STA multiplier+1
    STA preload+1
    STA multiplicand+1
    JSR mult16_preload
    LDA product
    LDX product+1
    RTS

\  CALCULATE SCREEN ADDRESS FROM DIGIT POSITION
\  ON ENTRY X, Y GIVE DIGIT POSITION
\  A IS PRESERVED 

.calc_digit_pos
    PHA
    STY scr_ptr             \  Place copy of Y co-ordinate in pointer
    LDA #0
    STA scr_ptr+1
    TYA                 \  Work with Y co-ordinate in A
    ASL  A
    ASL  A              \  Now A = Y * 4
    CLC                 \  No harm in making sure
    ADC scr_ptr         \  Add the copy we saved earlier
    STA scr_ptr         \  Now [scr_ptr] = Y * 5 ; max. value = 40
    ASL scr_ptr
    ASL scr_ptr
    ASL scr_ptr         \  max. value = 320 -- may set C
    ROL scr_ptr+1
    ASL scr_ptr
    ROL scr_ptr+1       \  Now [scr_ptr, scr_ptr+1] = Y * 80
    TXA                 \  Work with X co-ordinate in A
    ASL  A
    ASL  A              \  Now A = X * 4
    CLC
    ADC scr_ptr
    STA scr_ptr
    BCC _cdp1           \  Skip if no carry
    INC scr_ptr+1       \  Now [scr_ptr, scr_ptr+1] = Y * 80 + X * 4
._cdp1
    CLC                 \  Add beginning of screen to [scr_ptr, scr_ptr+1]
    LDA #&7C
    ADC scr_ptr+1
    STA scr_ptr+1
    PLA                 \  Retrieve the value saved earlier
.safe_return
    RTS
    
\  WRITE DIGIT A IN POSITION (X, Y)
\
\  On entry X => X co-ordinate in main grid
\           Y => Y co-ordinate in main grid
\           A = Digit to write; 0 erases digit

.write_digit
    JSR calc_digit_pos
    ASL  A
    ASL  A              \  Now A = digit * 4
    TAX                 \  This is index into table.
    LDY #1
    JSR digit_row
    JSR digit_row2
    LDY #41
    JSR digit_row
.digit_row2
    LDA #&20
    STA (scr_ptr),Y
    RTS
.digit_row
    JSR digit_row1
.digit_row1
    LDA digit_patt,X
    INX
    STA (scr_ptr),Y
    INY
    RTS
    
\  CALCULATE SCREEN ADDRESS FOR PENCIL MARK POSITION
\  Pencil marks are a 3*3 grid of dots
\
\   1  2  3
\   4  5  6
\   7  8  9
\
\  On entry X => X co-ordinate in main grid
\           Y => Y co-ordinate in main grid

.calc_pmk_pos
    JSR calc_digit_pos
    STA &72             \  Save copy of A
    ASL  A              \  Multiply by 2
    ADC &72             \  Add copy to get 3 * digit
    ASL  A              \  Double to get 6 * digit
    TAX
    LDY #1
    RTS

\  SET A PENCIL MARK
    
.set_pmk
    JSR calc_pmk_pos
    JSR set_row
    LDY #41             \  Beginning of second row
.set_row                \  Set row of pixel pattern for digit
    JSR set_row1
    JSR set_row1
.set_row1
    LDA (scr_ptr),Y
    ORA pmk_patt,X
    JMP pmk_write

\  CLEAR A PENCIL MARK

.clr_pmk
    JSR calc_pmk_pos
    JSR clr_row
    LDY #41             \  Beginning of second row
.clr_row                \  Unset row of pixel pattern for digit
    JSR clr_row1
    JSR clr_row1
.clr_row1
    LDA (scr_ptr),Y
    ORA pmk_patt,X      \  Setting and inverting just the bit we want is
    EOR pmk_patt,X      \  quicker than inverting it to create a mask
    JMP pmk_write
    
\  TOGGLE A PENCIL MARK ON <-> OFF

.toggle_pmk
    JSR calc_pmk_pos
    JSR toggle_row
    LDY #41             \  Beginning of second row
.toggle_row             \  EOR pixel pattern row for digit with screen
    JSR toggle_row1
    JSR toggle_row1
.toggle_row1
    LDA (scr_ptr),Y
    EOR pmk_patt,X
.pmk_write
    INX                 \  Next position in pattern
    STA (scr_ptr),Y
    INY                 \  Next position on screen
    RTS

.set_digit_colour
    JSR calc_digit_pos
    AND #&07
    BNE _sdc_not0
    LDA #7
._sdc_not0
    ORA #&90            \  Set graphics colour
    LDY #0
    STA (scr_ptr), Y
    LDY #40
    STA (scr_ptr), Y
    RTS

.calc_see_pos
    STX preload         \  Begin with X in preload ...
    STY multiplier      \  ... Y in multiplier ...
    LDA #81             \  ... 81 in multiplicand
    STA multiplicand
    LDA #0              \  All high bytes are 0 
    STA multiplier+1
    STA preload+1
    STA multiplicand+1
    JSR mult16_preload
    LDA product
    AND #&07            \  Equivalent to MOD 8
    TAX                 \  Now X holds position MOD 8
    LSR product+1
    ROR product
    LSR product+1
    ROR product
    LSR product+1
    ROR product         \  Equivalent to DIV 8
    CLC
    LDA product
    ADC #vision_map MOD256
    STA see_ptr
    LDA product+1
    ADC #vision_map DIV256
    STA see_ptr+1
    LDY #0
    LDA (see_ptr), Y
    RTS
    
.get_see
    JSR calc_see_pos
    AND bits_HL, X
    RTS
    
.set_see
    JSR calc_see_pos
    ORA bits_HL, X
    BNE _clr_see1       \  Always branches
.clr_see
    JSR calc_see_pos
    ORA bits_HL, X      \  Set it
    EOR bits_HL, X      \  Toggle it
._clr_see1
    STA (see_ptr), Y
    RTS

.set_pixel
    JSR get_pixel_pos
    ORA (scr_ptr), Y
    STA (scr_ptr), Y
    RTS
.clr_pixel
    JSR get_pixel_pos
    EOR #&FF
    AND (scr_ptr), Y
    STA (scr_ptr), Y
    RTS
    
\  GET PIXEL POSITION
\
\  Expects X = 0 .. 77 and Y = 0 .. 74  (NB: 0 is at top!)
\
\  On return, scr_ptr points to screen location
\             A = bit mask for pixel within character cell

.get_pixel_pos
    TYA                 \  Prepare to divide Y co-ordinate by 3
    LDY #0              \  Clear high byte of screen pointer
    STY scr_ptr+1
    JSR divide_by_3     \  Now A = answer, Y = remainder
    STA scr_ptr         \  Save a copy of (Y DIV 3)
    ASL A
    ASL A
    CLC
    ADC scr_ptr         \  Now [scr_ptr] = 5 * (Y DIV 3) ; max. = 120
    STA scr_ptr
    ASL scr_ptr         \  Max. value = 240
    ASL scr_ptr         \  This one might generate a carry
    ROL scr_ptr+1
    ASL scr_ptr
    ROL scr_ptr+1       \  Now [scr_ptr] = 40 * (Y DIV 3) ; max. = 960
    TXA                 \  X co-ordinate 0..77
    LSR A               \  Halve it, shifting LSB into carry
    PHP                 \  Save carry flag for later
    SEC                 \  Add extra 1 to skip graphics colour ctrl code
    ADC scr_ptr         \  Add horizontal character position
    STA scr_ptr         \  Now [scr_ptr] = 40 * (Y DIV 3) + (X DIV 2) + 1
    LDA scr_ptr+1
    ADC #&7C            \  Add high byte of address of start of screen
    STA scr_ptr+1
    PLP                 \  Retrieve carry flag => old lowest bit of X
    BCC _gpp_lhs        \  Skip for a pixel on the left-hand side
._gpp_rhs
    INY
    INY
    INY                 \  Now we point to right-hand pixel value
._gpp_lhs
    LDA lh_pixels, Y    \  
    LDY #0
    RTS

.lh_pixels
    EQUB &01:EQUB &04:EQUB &10
.rh_pixels
    EQUB &02:EQUB &08:EQUB &40

.show_seen
    STX fix_pos
    STY pixelY
    LDA #0
    STA var_pos
._ss_row
    LDA #68
    STA pixelX
._ss_col
    LDX fix_pos
    LDY var_pos
    JSR get_see
    PHP                 \  Save Z flag for later
    LDX pixelX
    LDY pixelY
    PLP                 \  Retrieve Z flag
    BEQ _ss_0
    JSR set_pixel
    BNE _ss_next        \  Will always branch
._ss_0
    JSR clr_pixel
._ss_next
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #77
    BCC _ss_col
    INC pixelY
    LDA var_pos
    CMP #81
    BCC _ss_row
    RTS

.clr_seen
    LDX #68
    JSR get_pixel_pos   \  Now [scr_ptr] is set
    LDX #14    
.cs_char
    LDA map_pos, X
    TAY
    LDA #32
    STA (scr_ptr), Y
    DEX
    BPL cs_char
    RTS

\  RESET THE GRID TO COMPLETELY EMPTY
\
\  BIT PATTERN FOR EACH CELL IN THE GRID IS INITIALLY AS FOLLOWS;
\
\  cands_17, X          cands_89v, X
\           01111111            11000000
\           ||||||||            ||  ||||
\           |1|3|5|7            |9  `--'
\           | 2 4 6             8   value
\      solved

.reset_grid
    LDX #0
    STX solved          \  No digits solved to begin with
._rsg_0
    LDA #&7F
    STA cands_17, X     \  01111111 => Not solved, can be 1-7
    LDA #&C0
    STA cands_89v, X    \  11000000 => Can be 8-9
    INX
    CPX #81
    BCC _rsg_0
    RTS
    
\  TEST WHETHER A CANDIDATE IS ALLOWED IN A CELL
\  X => CELL TO TEST
\  A => CANDIDATE TO TEST FOR

.test_candidate
    TAY                 \  Candidate for which we are testing
.test_cand_Y
    CPY #8              \  See which byte candidate belongs to
    BCS _tc_89
._tc_17
    LDA cands_17, X     \  Byte with candidates 1-7
    AND bits_HL, Y      \  AND with bit for candidate
    RTS
._tc_89
    LDA cands_89v, X    \  Byte with candidates 8-9 and value
    AND bits_HL-8, Y    \  AND with bit for candidate
    RTS

\  ELIMINATE A CANDIDATE FROM A CELL
\  X => CELL TO ELIMINATE FROM
\  A => CANDIDATE TO ELIMINATE

.eliminate_candidate
    CLV                 \  V=0 => not naked single
    TAY                 \  Save the candidate
\    LDA #33             \  "!"
\    JSR oswrch
\    TXA
\    PHA
\    TYA
\    JSR disp_digit      \  Digit being eliminated
\    PLA
\    TAX
\    JSR disp_hex_cands  \  Hex rep of destination and candidates
\    JSR osnewl
    LDA cands_17, X
    BPL _ec_not_solved  \  Exit if already solved
._ec_never_set
    SEC                 \  C=1 => candidate was never allowed
    RTS
._ec_not_solved
    CPY #8
    BCS _ec_89
._ec_17
    AND bits_HL, Y
    BEQ _ec_never_set   \  Exit if candidate was never allowed
    LDA cands_17, X     \  Byte with candidates 1-7
    ORA bits_HL, Y
    EOR bits_HL, Y
    STA cands_17, X     \  Store new candidates
    JMP _ec_done
._ec_89
    LDA cands_89v, X    \  Byte with candidates 8-9
    AND bits_HL-8, Y
    BEQ _ec_never_set
    LDA cands_89v, X    \  Byte with candidates 8-9
    ORA bits_HL-8, Y
    EOR bits_HL-8, Y
    STA cands_89v, X    \  Store new candidates
._ec_done

    TXA
    PHA
    TAX
    JSR disp_pos
    JSR say
    EQUS " cannot be "
    BRK
    TYA
    JSR disp_digit
    LDA #46             \  "."
    JSR oswrch
    JSR osnewl
    PLA
    TAX
    
    CLV                 \  V=0 => not naked single
    CLC                 \  C=0 => candidate successfully eliminated
    
    \  MAKE SURE SOME CANDIDATES ARE STILL ALLOWED.
    \  IF ONLY ONE REMAINS -- CONSIDER CELL SOLVED
    
._ec_count_cands
    \TXA
    \PHA
    \JSR disp_pos
    \JSR say
    \EQUS " can be:"
    \BRK
    \PLA
    \TAX
    JSR count_cands
    CMP #1
    BNE _ctc_not_naked
._ctc_naked
    \  ONLY ONE POSSIBLE CANDIDATE REMAINS = NAKED SINGLE!
    \  DIGIT VALUE MUST BE IN preload
    LDA #&80
    STA cands_17, X     \  Set "solved" bit
    LDA preload
    STA cands_89v, X    \  Store cell value
    INC solved          \  Increase solved count
    \JSR _ctc_naked1
    TXA
    PHA
    JSR disp_pos
    JSR say
    EQUS " can only contain "
    BRK
    LDA preload
    JSR disp_digit
    LDA #33             \  "!"
    JSR oswrch
    JSR osnewl
    PLA
    TAX
    LDA digit
    PHA
    TXA
    PHA
    LDA cands_89v, X
    JSR elim_out
    PLA
    TAX
    PLA
    STA digit
    
    LDY preload
    BIT _ctc_rts        \  This will set V=1 => cell now solved
    RTS
._ctc_not_naked
    CLV                 \  V=0 => not naked single
    CLC                 \  C=0 => successful elimination, A is count
._ctc_rts
    RTS
        
.count_cands
    JSR copy_cands
    LDA #0
    STA multiplier      \  Use this to count allowed digits
    STA preload         \  This is initially 0
    LDY #1              \  Digit we are testing for
    JSR asl_cand_copy   \  Skip "solved" bit
._ncc_digit
    JSR asl_cand_copy
    BCC _ncc_not_allowed
    INC multiplier      \  Increase count of digits allowed
    STY preload         \  Update highest allowed digit
    \TYA
    \JSR disp_digit
._ncc_not_allowed
    INY
    CPY #10
    BCC _ncc_digit
    \LDA #46
    \JSR oswrch
    \LDA multiplier      \  Return count of candidates allowed
    \JSR disp_digit_sp
    \JSR say
    \EQUS "left."
    \BRK
    \JSR osnewl
    LDA multiplier      \  Return count of candidates allowed    
    RTS
    
.copy_cands
    LDA cands_17, X
    STA cand_copy
    LDA cands_89v, X
    STA cand_copy+1
    RTS

\  SET A DIGIT TO A DEFINITE VALUE

.set_digit
    JSR test_candidate
    BNE _sd_1
    BRK
    EQUB E_NOT_ALLOWED
    EQUS "Not allowed"
    BRK
._sd_1
    LDA #&80
    STA cands_17, X     \  Bit 7=1 => cell is solved
    TYA
    STA cands_89v, X    \  Solved digit value
    INC solved
    RTS
    
\  CLEAR A DIGIT VALUE

.clr_digit
    LDA cands_17, X     \  See if cell is already solved ...
    BPL _cdt_0          \  ... Skip if not
    DEC solved          \  Decrease count of solved digits
._cdt_0
    LDA #&7F            \  Unsolved; can be 1, 2, 3, 4, 5, 6, 7
    STA cands_17, X
    LDA #&C0            \  can be 8, 9
    STA cands_89v, X
    RTS
    
\  COUNT UP SOLVED DIGITS

.count_solved
    LDX #0
    STX solved          \  Start with no digits solved
._csd_0
    LDA cands_17, X     \  Test whether cell is solved
    AND #&80            \  Bit 7 => solved
    BEQ _csd_1          \  Skip if not solved
    INC solved          \  Increase count of solved digits
._csd_1
    INX                 \  Move onto next cell
    CPX #81
    BCC _csd_0          \  Go round again if any more cells untested
    RTS

\  CONVERT A CELL POSITION 0..80 IN A OR X TO A PAIR OF CO-ORDINATES
\  WHICH WILL BE RETURNED IN X AND Y

.conv_xy                \  Position is in A to begin with
    TAX
.conv_xyX               \  Position is already in X
    LDA xy_coords, X    \  Now high nybble = Y, low nybble = X
    TAX
    JSR lsra4           \  Shift down high nybble ...
    TAY                 \  ... giving Y co-ordinate
    TXA
    AND #&0F            \  Mask out Y co-ordinate in high nybble ...
    TAX                 \  ... leaving X co-ordinate
    RTS

\  SHIFT ACCUMULATOR RIGHT 4 PLACES
\  (4 bytes + RTS, but a JSR here is only 3 bytes)
    
.lsra4
    LSR A
    LSR A
    LSR A
    LSR A
    RTS

\  CONVERT A CELL POSITION 0..80 TO A HUMAN-READABLE ROW AND COLUMN
\  E.G.  0 => R1C1, 12 => R2C4, 40 => R5C5, 63 => R7C1, 80 => R9C9
\  POSITION SHOULD BE IN X
\  PRESERVES A, X AND Y
    
.disp_pos
    PHA
    TYA
    PHA
    TXA
    PHA
    JSR conv_xyX
    LDA #&52            \  "R"
    JSR oswrch
    TYA
    SEC                 \  display row number starting from 1
    ADC #&30            \  ASCII code for 0
    JSR oswrch
    LDA #&43            \  "C"
    JSR oswrch
    TXA
    SEC                 \  display column number starting from 1
    ADC #&30
    JSR oswrch
    PLA
    TAX
    PLA
    TAY
    PLA
    RTS

\  EXTENDED VERSION; DISPLAYS THE POSITION AND ITS CANDIDATE DIGITS
\  CARE: USES EVEN MORE STACK!

.disp_pos_ext
    PHA
    TYA
    PHA
    TXA
    PHA
    
    JSR conv_xyX
    LDA #&52            \  "R"
    JSR oswrch
    TYA
    SEC                 \  display row number starting from 1
    ADC #&30            \  ASCII code for 0
    JSR oswrch
    LDA #&43            \  "C"
    JSR oswrch
    TXA
    SEC                 \  display column number starting from 1
    ADC #&30
    JSR oswrch
    LDA #61             \  =
    JSR oswrch
    
    TSX
    LDA &101, X         \  This will give X we pushed
    TAX
    
    LDA cand_copy       \  Save the copy of the candidates ...
    PHA
    LDA cand_copy+1
    PHA
    
    JSR copy_cands      \  ... which will get trashed
    LDY #1              \  Digit we are testing for
    JSR asl_cand_copy   \  Skip "solved" bit
._dpe_digit    
    JSR asl_cand_copy
    BCC _dpe_not_allowed
    TYA
    JSR disp_digit
._dpe_not_allowed
    INY
    CPY #9
    BCC _dpe_digit
    LDA #46
    JSR oswrch

    PLA                 \  Restore copy of candidates
    STA cand_copy+1
    PLA
    STA cand_copy

    PLA
    TAX
    PLA
    TAY
    PLA
    RTS

\  DISPLAY THE CONTENTS OF A CELL; EITHER AS A DIGIT IF IT IS SOLVED, OR
\  AS A CONSTELLATION OF PENCIL MARKS IF IT IS NOT YET SOLVED.

.disp_contents
    PHA
    TYA
    PHA
    TXA
    PHA
    LDA digit
    PHA
    JSR copy_cands
    JSR conv_xyX        \  Now X, Y hold co-ords
    BIT cand_copy       \  Bit 7 = 1 => solved
    BPL _dcc_pmark
._dcc_digit
    LDA cand_copy+1     \  Solved digit value
    JSR write_digit
    JMP _dcc_end
._dcc_pmark
    STX tempX           \  Save X co-ordinate
    STY tempY           \  Save Y co-ordinate
    JSR asl_cand_copy   \  Avoid a useless first trip around the loop
    LDA #1
    STA digit
._dcc_test
    JSR asl_cand_copy
    BCC _dcc_pmk_0
    JSR set_pmk
    JMP _dcc_next
._dcc_pmk_0
    JSR clr_pmk
._dcc_next
    INC digit
    LDA digit
    LDX tempX           \  Retrieve X co-ordinate
    LDY tempY           \  Retrieve Y co-ordinate
    CMP #10
    BCC _dcc_test       \  Test next candidate
._dcc_end
    PLA
    STA digit
    PLA
    TAX
    PLA
    TAY
    PLA
    RTS

\  TAKE A TALLY OF DIGITS WITHIN A SET
\
\  
    
.reset_tally
    LDX #9
    LDA #0
._ccc_1
    STA cand_count, X
    DEX
    BPL _ccc_1
    RTS

.update_tally
    LDA cands_17, X
    STA cand_copy       \  Make copy of allowed candidates
    BPL _udt_not_solved
    INC cand_count      \  Count of "zeros" is count of solved digits
    CLC                 \  C=0 => was already solved
    RTS
._udt_not_solved
    LDA cands_89v, X
    STA cand_copy+1
    LDX #0              \  First pass will do nothing, but the saving in
._udt_test_digit        \  cycles is hardly worth the extra bytes.
    JSR asl_cand_copy   \  Now C=1 => candidate was allowed
    BCC _udt_not_allowed
    INC cand_count, X   \  Increase count of allowed digit
._udt_not_allowed
    INX
    CPX #10
    BCC _udt_test_digit
    RTS                 \  With C=1
.asl_cand_copy
    ASL cand_copy+1
    ROL cand_copy
    RTS
    
\  TEST WHETHER A CANDIDATE IS ALLOWED IN A CELL
\  X => CELL TO TEST
\  ON RETURN A=0 => NOT SOLVED
\            A>0 => CELL VALUE

.test_solved
    TAY                 \  Save the candidate
    LDA cands_17, X     \  Bit 7=1 => is solved
    BMI _tsv_solved
    LDA #0              \  Z=1; will cause BEQ to branch
    RTS
._tsv_solved
    LDA cands_89v, X    \  Contains solved value
    RTS
    
\  ELIMINATE CANDIDATES FROM CELLS, WORKING OUTWARDS
\  THIS IS SAFELY RE-ENTRANT, SO WE CAN CHASE UP NAKED SINGLES

\  ORIGINAL BASIC
\
\ 5100DEFPROCman_elim_out(I%,D%)
\ 5110LOCALJ%,E%
\ 5112PRINT"Showing contents of ";:PROCdisp_pos(I%):PRINT
\ 5114PROCdisp_cont(I%)
\ 5120FORJ%=0TO80
\ 5130IFJ%=I%GOTO5190
\ 5140IFFNsee(I%,J%)=0GOTO5190
\ 5150IFFNsolved(J%)GOTO5190
\ 5160E%=FNelim_cand(J%,D%)
\ 5170IF(E%AND&1000000)=0PRINT;D%;" in ";:PROCdisp_pos(I%):PRINT" sees ";:PROCdisp_pos(J%):PRINT
\ 5180PROCdisp_cont(J%)
\ 5190NEXT
\ 5200ENDPROC
    
.elim_out

\ 5100DEFPROCman_elim_out(I%,D%)
\ 5110LOCALJ%,E%

    STA digit
    LDA fix_pos
    PHA
    LDA var_pos
    PHA

\ 5112PRINT"Showing contents of ";:PROCdisp_pos(I%):PRINT
\ 5114PROCdisp_cont(I%)

    STX fix_pos
    LDY #66
    JSR show_seen
    LDX fix_pos
    JSR disp_contents

\ 5120FORJ%=0TO80

    LDX #0
    STX var_pos
._neo_test

\ 5130IFJ%=I%GOTO5190

    CPX fix_pos
    BEQ _neo_no_elim    \  No elimination from same cell
    
\ 5140IFFNsee(I%,J%)=0GOTO5190

    LDY fix_pos
    JSR get_see
    BEQ _neo_no_elim    \  No elimination if does not see

\ 5150IFFNsolved(J%)GOTO5190
\ 5160E%=FNelim_cand(J%,D%)

    LDX fix_pos
    LDA cands_89v, X    \  The digit in the fixed position ...
    LDX var_pos         \  ... gets eliminated from the variable position
    JSR eliminate_candidate
    
    BCS _neo_no_elim    \  No elimination if never allowed
    BCS _neo_miss       \  No elimination if never allowed

._neo_hit
    BVC _neo_not_naked
    BVS _neo_not_naked

.neo_naked_error
    BRK
    EQUB 56
    EQUS "Naked single"
    BRK
    
\ 5170IF(E%AND&1000000)=0PRINT;D%;" in ";:PROCdisp_pos(I%):PRINT" sees ";:PROCdisp_pos(J%):PRINT

._neo_not_naked

\ 5180PROCdisp_cont(J%)

    LDX var_pos
    JSR disp_contents

\ 5190NEXT

._neo_no_elim
    INC var_pos
    LDX var_pos
    CPX #81
    BCC _neo_test

\ 5200ENDPROC

    PLA
    STA var_pos
    PLA
    STA fix_pos
    RTS
    
._neo_miss
    LDX fix_pos
    LDA cands_89v, X
    ADC #47             \  We know C=1 here
    JSR oswrch
    JSR say
    EQUS " in "
    BRK
    LDX fix_pos
    JSR disp_pos
    JSR say
    EQUS " misses "
    BRK
    LDX var_pos
    JSR disp_pos
    JSR osnewl
    JMP _neo_no_elim

\  ELIMINATE CANDIDATES FROM A CELL, WORKING INWARDS
\  SAFELY RE-ENTRANT

.elim_in
    LDA fix_pos         \  Save fixed and variable positions
    PHA                 \  (which we are going to stomp on)
    LDA var_pos
    PHA

    STX fix_pos
    LDY #66
    JSR show_seen

    LDX #0
    STX var_pos
    
._nei_test
    CPX fix_pos         \  Skip if same position
    BEQ _nei_no_elim
    LDY fix_pos
    JSR get_see
    BEQ _nei_no_elim    \  No elimination if does not see
    LDX var_pos
    JSR test_solved     \  See if digit is solved
    BEQ _nei_no_elim
    
    STA digit           \  Remember digit for later
    LDX fix_pos
    JSR eliminate_candidate
    BCS _nei_no_elim
    JSR _nei_elim       \  Display message about elimination
    
    LDX var_pos
    BVC _nei_not_naked
    
    JSR say
    EQUS "Naked single"
    BRK
    
    LDA #80             \  Jump to end of grid
    STA var_pos
    
._nei_not_naked
    LDX fix_pos
    JSR disp_contents
    
._nei_no_elim
    INC var_pos
    LDX var_pos
    CPX #81
    BCC _nei_test
    
    PLA                 \  Restore the previous positions
    STA var_pos
    PLA
    STA fix_pos
    RTS
    
._nei_elim
    PHP
    PHA
    TYA
    PHA
    TXA
    PHA
    
    LDX fix_pos         \  Display fixed position
    JSR disp_pos
    JSR say
    EQUS " sees "
    BRK
    LDA digit           \  Display digit in seen cell
    JSR disp_digit_sp
    JSR say
    EQUS "in "
    BRK
    LDX var_pos         \  Display variable position
    JSR disp_pos
    JSR osnewl
    
    PLA
    TAX
    PLA
    TAY
    PLA
    PLP
    RTS

\  SHOW ALL INSTANCES OF A CANDIDATE

.show_instances
    STX digit
    STY pixelY
    LDA #0
    STA var_pos
._shi_row
    LDA #68
    STA pixelX
._shi_col
    LDX var_pos
    JSR test_solved
    BNE _shi_0
    LDY digit
    JSR test_cand_Y
    BEQ _shi_0
    LDX pixelX
    LDY pixelY
    JSR set_pixel
    BNE _shi_next       \  Will always branch
._shi_0
    LDX pixelX
    LDY pixelY
    JSR clr_pixel
._shi_next
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #77
    BCC _shi_col
    INC pixelY
    LDA var_pos
    CMP #81
    BCC _shi_row
    RTS

\  CONVERT A BIT OFFSET IN Y, TO A BYTE OFFSET IN Y AND A SUB-OFFSET
\  TO A BIT WITHIN THAT BYTE IN X
    
.calc_set_ofs
    TYA                 \  Copy Y to accumulator
    TAX                 \  Also make a copy in X
    LSR A               \  Divide by 8 ...
    LSR A
    LSR A
    TAY                 \  ... and store in Y
    TXA                 \  Retrieve copy
    AND #7              \  Get remainder modulo 8 ...
    TAX                 \  ... and store in X
    RTS
    
.get_set_cell
    JSR calc_set_ofs
    LDA (set_ptr), Y
    AND bits_HL, X      \  Z=0 => bit was 1
    RTS

.set_set_cell
    JSR calc_set_ofs
    LDA (set_ptr), Y
    ORA bits_HL, X
    STA (set_ptr), Y
    RTS

.clr_set_cell
    JSR calc_set_ofs
    LDA (set_ptr), Y
    ORA bits_HL, X      \  force it to 1 ...
    EOR bits_HL, X      \  ... then invert it
    STA (set_ptr), Y
    RTS

\  SHOW THE IN/OUT STATUS OF A SET OF GRID SQUARES
\  ON ENTRY Y = VERTICAL POSITION
\           set-ptr,set_ptr+1 => SET TO DISPLAY

.show_set
    STY pixelY
    LDA #0
    STA var_pos
._shs_row
    LDA #68
    STA pixelX
._shs_col
    LDY var_pos
    JSR get_set_cell
    PHP                 \  Save Z flag for later
    LDX pixelX
    LDY pixelY
    PLP                 \  Retrieve Z flag
    BEQ _shs_0
    JSR set_pixel
    BNE _shs_next       \  Will always branch
._shs_0
    JSR clr_pixel
._shs_next
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #77
    BCC _shs_col
    INC pixelY
    LDA var_pos
    CMP #81
    BCC _shs_row
    RTS

\  TEST WHETHER A CELL IS WITHIN THE ALTERNATE SET
\  ON RETURN Z=1 => CELL WAS NOT IN ALT SET
    
.get_alt_cell
    JSR calc_set_ofs    \  This works the same either way
    LDA (alt_ptr), Y
    AND bits_HL, X      \  Z=0 => bit was 1
    RTS

.set_alt_cell
    JSR calc_set_ofs
    LDA (alt_ptr), Y
    ORA bits_HL, X
    STA (alt_ptr), Y
    RTS

.clr_alt_cell
    JSR calc_set_ofs
    LDA (alt_ptr), Y
    ORA bits_HL, X      \  force it to 1 ...
    EOR bits_HL, X      \  ... then invert it
    STA (alt_ptr), Y
    RTS

\  SHOW THE IN/OUT STATUS OF THE ALTERNATE SET OF GRID SQUARES
\  ON ENTRY Y = VERTICAL POSITION
\           alt-ptr,alt_ptr+1 => SET TO DISPLAY

.show_alt
    LDA var_pos
    PHA
    STY pixelY
    LDA #0
    STA var_pos
._sha_row
    LDA #68
    STA pixelX
._sha_col
    LDY var_pos
    JSR get_alt_cell
    PHP                 \  Save Z flag for later
    LDX pixelX
    LDY pixelY
    PLP                 \  Retrieve Z flag
    BEQ _sha_0
    JSR set_pixel
\    LDA #42             \  "*"
\    JSR oswrch
\    JMP _sha_next
    BNE _sha_next       \  Will always branch
._sha_0
    JSR clr_pixel
\    LDA #46             \  "."
\    JSR oswrch
._sha_next
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #77
    BCC _sha_col
\    JSR osnewl
    INC pixelY
    LDA var_pos
    CMP #81
    BCC _sha_row
    PLA
    STA var_pos
    RTS
    
\  TAKE THE INTERSECTION OF THE ALTERNATE SET WITH WHATEVER IS SEEN BY
\  A POSITION GIVEN IN X

.and_alt_seen
    LDA fix_pos
    PHA
    LDA var_pos
    PHA
    STX fix_pos         \  The digit we care what sees    
    LDA #0
    STA var_pos
    TAX
._aas_0
    LDY fix_pos
    JSR get_see
    BNE _aas_1          \  Skip if cells see each other
    LDY var_pos
    JSR clr_alt_cell    \  Clear cell if it was not seen
._aas_1
    INC var_pos
    LDX var_pos
    CPX #81             \  See if we have reached end
    BCC _aas_0
._aas_done
    PLA
    STA var_pos
    PLA
    STA fix_pos
    RTS

    
\  TALLY UP THE POSSIBLE CANDIDATES FOR THE CELLS IN A SET
\  ON RETURN; cand_count     => SOLVED CELLS
\             cand_count + 1 => POSSIBLE 1S
\             cand_count + 2 => POSSIBLE 2S
\               ...
\             cand_count + 9 => POSSIBLE 9S
\  SOLVED CELLS DO NOT COUNT TOWARDS CANDIDATE COUNTS!
\  IF A DIGIT CAN GO IN ONLY ONE CELL, WE NEED TO PUT
\  IT THERE!

.tally_set
    JSR reset_tally     \  This will leave 0 in A
    STA var_pos
._tys_pos
    LDY var_pos
    JSR get_set_cell    \  See if cell is in set
    BEQ _tys_not_in     \  Skip if not in set
    LDX var_pos
    JSR update_tally
._tys_not_in
    INC var_pos
    LDA var_pos
    CMP #81
    BCC _tys_pos
    RTS

.fill_set
    STA digit
    LDX #0
    STX var_pos
._fis_pos
    LDY var_pos
    JSR get_set_cell    \  See if cell is in set
    \JSR _fis_dbg
    BEQ _fis_not_in     \  Skip if not in set
    
    LDX var_pos
    LDA digit
    JSR test_candidate
    BEQ _fis_not_in

    LDA digit
    CLC
    ADC #48
    JSR oswrch
    JSR say
    EQUS " can only go in "
    BRK
    LDX var_pos
    JSR disp_pos
    LDA #46
    JSR oswrch
    JSR osnewl
    
    LDA digit
    LDX var_pos
    JSR set_digit
    JSR disp_contents
    LDA digit
    LDX var_pos
    JSR elim_out
._fis_not_in
    LDA solved          \  Terminate loop early if puzzle is finished
    CMP #81
    BCS _fis_done
    INC var_pos
    LDX var_pos
    CPX #81
    BCC _fis_pos
._fis_done
    RTS
    
._fis_dbg
    PHP
    LDX var_pos
    JSR disp_pos
    PLP
    PHP
    BEQ _fis_dbg_0
.fis_dbg_1
    LDA #121 \ y
    BNE _fis_dbg_any
._fis_dbg_0
    LDA #110 \ n
._fis_dbg_any
    JSR oswrch
    PLP
    RTS

.elim_set
    LDA #0
    STA var_pos
._els_pos
    LDY var_pos
    JSR get_set_cell    \  See if cell is in set
    BEQ _els_not_in     \  Skip if not in set
    
    LDX var_pos
    JSR test_solved
    BEQ _els_not_solved
.els_solved
    \LDA digit
    LDX var_pos
    LDA cands_89v, X
    JSR elim_out        \  Eliminate candidates it sees
    JMP _els_not_in
._els_not_solved
    JSR elim_in         \  Eliminate anything seen as candidate
    LDX var_pos
._els_not_in
    INC var_pos
    LDA solved          \  Terminate loop early if puzzle is finished
    CMP #81
    BCS _els_done
    LDX var_pos
    CPX #81
    BCC _els_pos
._els_done
    RTS
    
    
\  INITIALISE THE ALTERNATE SET TO ALL ZEROS

.init_alt_zero
    LDY #10
    LDA #0
._ia0_0
    STA (alt_ptr), Y
    DEY
    BPL _ia0_0
    RTS

\  INITIALISE THE ALTERNATE SET TO ALL ONES

.init_alt_one
    LDY #10
    LDA #&80            \  Take care of the odd bit
    STA (alt_ptr), Y
    DEY
    LDA #&FF            \  Now we can do the rest all the same
._ia1_0
    STA (alt_ptr), Y
    DEY
    BPL _ia1_0
    RTS

\  INITIALISE THE ALTERNATE SET TO INCLUDE ALL CELLS NOT IN THE
\  MAIN SET
    
.init_alt_for_all
    JSR init_alt_one
    
\  TAKE THE INTERSECTION OF THE ALTERNATE SET WITH THE COMPLEMENT
\  OF THE MAIN SET

.excl_set_alt
    LDA var_pos
    PHA
    LDY #0
    STY var_pos
._esa_test
    JSR get_set_cell    \  Y already contains variable position
    BEQ _esa_not_in     \  Skip if not in main set
    LDY var_pos
    JSR clr_alt_cell    \  Exclude this position from alt set
._esa_not_in
    INC var_pos
    LDY var_pos
    CPY #81
    BCC _esa_test
    PLA
    STA var_pos
    RTS
    
\  TEST TO SEE IF ANY CELLS ARE STILL INCLUDED IN THE ALTERNATE SET
\  ON RETURN Z=1 => NO CELLS
\            Z=0 => ONE OR MORE CELLS

.test_alt
    LDY #10
    LDA (alt_ptr), Y
    AND #&80            \  Ignore bits 81-87
    DEY                 \  Everything else is included
.tea_0
    ORA (alt_ptr), Y    \  Any ones will stick in A
    DEY
    BPL tea_0
\    PHP
\    TAY                 \  We care whether or not Y=0
\    BEQ _tea_empty
\    JSR say
\    EQUS "Not "
\    BRK
\._tea_empty
\    JSR say
\    EQUS "empty."
\    BRK
\    JSR osnewl
\    PLP
    TAY                 \  Make sure A is last thing seen
    RTS

\  REMOVE ALL CELLS FROM THE ALTERNATE SET THAT CANNOT CONTAIN A
\  PARTICULAR DIGIT, GIVEN IN ACCUMULATOR

.and_alt_digit
    TAY                 \  Save the digit
    LDA digit
    PHA
    STY digit
    LDA var_pos
    PHA
    LDY #0
    STY var_pos
._aad_test
    JSR get_alt_cell    \  See if cell is in alt set
    BEQ _aad_not_in
    LDX var_pos
    LDA digit
    JSR test_candidate  \  See if is a candidate
    BNE _aad_not_in     \  Skip if cell *is* a candidate
    LDY var_pos
    JSR clr_alt_cell    \  Remove cell from alt set
._aad_not_in
    INC var_pos
    LDY var_pos
    CPY #81
    BCC _aad_test
._aad_done
    PLA
    STA var_pos
    PLA
    STA digit
    RTS

\  INITIALISE THE ALTERNATE SET WITH ALL CELLS OUTSIDE THE MAIN SET, THAT
\  CAN CONTAIN A DIGIT GIVEN IN THE ACCUMULATOR
    
.init_alt_digit
    TAY                 \  Save the digit
    \LDA digit
    \PHA
    STY digit
    LDA var_pos
    PHA
    LDY #0
    STY var_pos
._iad_test
\    LDX var_pos
\    JSR disp_pos
    LDY var_pos         \  needs to be in Y for this
    JSR get_set_cell
    BNE _iad_clear      \  Clear cell if it is in main set
    LDX var_pos
    LDA digit
    JSR test_candidate  \  See if is a candidate
    BEQ _iad_clear
._iad_set               \  Set cell in alternate set
    LDY var_pos
    JSR set_alt_cell
\    LDA #121            \  "y"
\    JSR oswrch
    JMP _iad_next
._iad_clear             \  Clear cell in alternate set
    LDY var_pos
    JSR clr_alt_cell
\    LDA #110            \  "n"
\    JSR oswrch
._iad_next
    INC var_pos
    LDY var_pos
    CPY #81
    BCC _iad_test
._iad_done
    \JSR osnewl
    PLA
    STA var_pos
    \PLA
    \STA digit
    RTS

\  ORIGINAL BASIC
\
\ 4670DEFPROCelim_ext(D%)
\ 4680LOCALA%,X%,Y%,I%,J%
\ 4690PROCinit_alt_d(D%):PROCshow_alt(66)
\ 4700FORI%=0TO80
\ 4710IFFNcell(I%)=0GOTO4730
\ 4720IFFNtest_cand(I%,D%)PROCand_seen(I%):PROCshow_alt(66):IFFNtest_alt=0I%=80
\ 4730NEXT
\ 4740IFFNtest_alt=0GOTO4780
\ 4750FORI%=0TO80
\ 4760IFFNalt(I%)PROCelim_cand(I%,D%)
\ 4770NEXT
\ 4780ENDPROC

\ 4670DEFPROCelim_ext(D%)
\ 4680LOCALA%,X%,Y%,I%,J%
\ 4690PROCinit_alt_d(D%):PROCshow_alt(66)

.elim_ext
    STA digit           \  The digit we are eliminating
    JSR init_alt_digit
    LDY #66
    JSR show_alt

\ 4700FORI%=0TO80

    LDY #0
    STY var_pos

\ 4710IFFNcell(I%)=0GOTO4730

._elx_test
    JSR get_set_cell
    BEQ _elx_not_in

\ 4720IFFNtest_cand(I%,D%)PROCand_seen(I%):PROCshow_alt(66):IFFNtest_alt=0I%=80

    LDX var_pos
\    JSR disp_pos
    LDA digit
    JSR test_candidate
\    PHP
\    BEQ _elx_n
\    LDA #121            \  "y"
\    JSR oswrch
\    JMP _elx_a
\._elx_n
\    LDA #110            \  "n"
\    JSR oswrch
\._elx_a
\    PLP
    BEQ _elx_not_in     \  Ignore non-candidates
    LDX var_pos
    JSR and_alt_seen    \  Strike out cells it does not see
    LDY #66
    JSR show_alt
    JSR test_alt        \  See if any candidates remain ...
    BEQ _elx_done       \  ... Skip if not

\ 4730NEXT

._elx_not_in
    INC var_pos
\    LDX var_pos
\    JSR disp_pos
\    LDA #58             \  colon
\    JSR oswrch
\    LDA var_pos
\    JSR disp_hex_byte
    LDY var_pos
    CPY #81
    BCC _elx_test

\ 4740IFFNtest_alt=0GOTO4780
\  We have already tested this ...

    \JSR say
    \EQUS "Search done"
    \BRK
    \JSR osnewl

\    JSR test_alt        \  See if any candidates remain ...
\    BEQ _elx_done       \  ... Skip if not

\ 4750FORI%=0TO80

    LDY #0
    STY var_pos
    
\ 4760IFFNalt(I%)PROCelim_cand(I%,D%)

._elx_elim
    JSR get_alt_cell
    BEQ _elx_no_elim
    LDX var_pos
    LDA digit
    JSR eliminate_candidate

\ 4770NEXT

._elx_no_elim
    INC var_pos
    LDY var_pos
    CPY #81
    BCC _elx_elim
    
\ 4780ENDPROC

._elx_done
    RTS

\  ELIMINATE INWARDS OR OUTWARDS FROM ALL CELLS IN THE GRID

.eliminate_all
    LDX #0
    STX var_pos
._ela_pos
    JSR test_solved
    BEQ _ela_not_solved
.ela_solved
    LDX var_pos
    LDA cands_89v, X
    JSR elim_out        \  Eliminate candidates it sees
    JMP _ela_any
._ela_not_solved
    JSR elim_in         \  Eliminate anything seen as candidate
    LDX var_pos
._ela_any
    INC var_pos
    LDA solved          \  Terminate loop early if puzzle is finished
    CMP #81
    BCS _ela_done
    LDX var_pos
    CPX #81
    BCC _ela_pos
._ela_done
    RTS

\  DISPLAY A SINGLE DIGIT

.disp_digit
    PHA
    ORA #&30
    JSR oswrch
    PLA
    RTS

\  DISPLAY A SINGLE DIGIT FOLLOWED BY A SPACE

.disp_digit_sp
    PHA
    ORA #&30
    JSR oswrch
    LDA #32
    JSR oswrch
    PLA
    RTS

.say
    PHP                 \  Stash everything on the 6502 stack
    PHA
    TYA
    PHA
    TXA
    PHA                 \  Now there are 4 bytes on top of return addr-1
    TSX                 \  &101 + stack pointer => most recently pushed
    LDA &105, X
    STA text_ptr        \  Low byte of return address-1
    LDA &106, X
    STA text_ptr+1      \  High byte of return address-1
    LDY #1              \  Start one ahead of address on stack
._ss_say_1
    LDA (text_ptr), Y
    BEQ _ss_say_2       \  Don't send CHR$(0)
    INY
    JSR osasci
    CMP #&20            \  Stop printing after any control char
    BCS _ss_say_1
    DEY                 \  We no longer need to compensate for address-1
._ss_say_2
    TYA                 \  Overwrite old return address with new value
    CLC                 \  adjusted by length of string we just printed
    ADC text_ptr
    TSX
    STA &105, X
    LDA text_ptr+1
    ADC #0
    STA &106, X
    PLA                 \  Retrieve the values we stashed earlier
    TAX
    PLA
    TAY
    PLA
    PLP
    RTS                 \  To the modified address

    
.dump_grid
    LDA #42
    JSR oswrch
.dump_grid1
    LDX #0
._dpg_0
    LDA cands_17, X
    JSR disp_hex_byte
    LDA cands_89v, X
    JSR disp_hex_byte
    INX
    CPX #81
    BCC _dpg_0
    JMP osnewl
    
.disp_hex_cands
    PHA
    TYA
    PHA
    TXA
    PHA
    LDA #43             \  "+"
    JSR oswrch
    TXA
    JSR disp_hex_byte
    LDA cands_17, X
    JSR disp_hex_byte
    LDA cands_89v, X
    JSR disp_hex_byte
    PLA
    TAX
    PLA
    TAY
    PLA
    RTS
    
.disp_hex_byte
    PHA
    JSR lsra4
    JSR disp_hex_nybble
    PLA
    AND #&F
.disp_hex_nybble
    ORA #&30
    CMP #&3A
    BCC _dhn_09
    ADC #6              \  We know C=1 here, because BCS did not branch
._dhn_09
    JMP oswrch
    
    
    
ALIGN &100

\  DIGIT PATTERNS
\
\  EACH DIGIT HAS 4 BYTES WHICH GIVE THE CHARACTER CODES FOR ITS GLYPH
\  IN EACH OF 2 ROWS OF 2 COLUMNS.  A THIRD, EMPTY COLUMN WILL BE ADDED
\  WHEN IT IS WRITTEN TO THE SCREEN.

.digit_patt
    EQUD &20202020
    EQUD &25203528
    EQUD &2C2D7B73
    EQUD &2E2C7B73
    EQUD &2A207A75
    EQUD &2E2C7377
    EQUD &2E2D7377
    EQUD &2A206B27
    EQUD &2E2D7B77
    EQUD &2E2C7B77
    \  digit "10" is underscore for cursor
    EQUD &70702020

\  PENCIL MARK PATTERNS
\
\  EACH DIGIT HAS 6 BYTES WHICH GIVE THE PIXEL VALUES IN EACH OF 2 ROWS
\  OF 3 COLUMNS.

.pmk_patt
    EQUW &0000:EQUD &00000000
    EQUW &0001:EQUD &00000000
    EQUW &0100:EQUD &00000000
    EQUW &0000:EQUD &00000001
    EQUW &0010:EQUD &00000000
    EQUW &1000:EQUD &00000000
    EQUW &0000:EQUD &00000010
    EQUW &0000:EQUD &00000400
    EQUW &0000:EQUD &00040000
    EQUW &0000:EQUD &04000000

\  X, Y CO-ORDINATES FOR GRID POSITIONS
\
\  HIGH NYBBLE = Y CO-ORDINATE
\  LOW NYBBLE  = X CO-ORDINATE

.xy_coords
    EQUD &03020100:EQUD &07060504:EQUB &08
    EQUD &13121110:EQUD &17161514:EQUB &18
    EQUD &23222120:EQUD &27262524:EQUB &28
    EQUD &33323130:EQUD &37363534:EQUB &38
    EQUD &43424140:EQUD &47464544:EQUB &48
    EQUD &53525150:EQUD &57565554:EQUB &58
    EQUD &63626160:EQUD &67666564:EQUB &68
    EQUD &73727170:EQUD &77767574:EQUB &78
    EQUD &83828180:EQUD &87868584:EQUB &88

.boxes
    EQUD &01000000:EQUD &02020101:EQUB &02
    EQUD &01000000:EQUD &02020101:EQUB &02
    EQUD &01000000:EQUD &02020101:EQUB &02
    EQUD &04030303:EQUD &05050404:EQUB &05
    EQUD &04030303:EQUD &05050404:EQUB &05
    EQUD &04030303:EQUD &05050404:EQUB &05
    EQUD &07060606:EQUD &08080707:EQUB &08
    EQUD &07060606:EQUD &08080707:EQUB &08
    EQUD &07060606:EQUD &08080707:EQUB &08

.bits_HL
    EQUD &10204080:EQUD &01020408
    
.map_pos
    EQUB 84:EQUB 83:EQUB 82:EQUB 81:EQUB 80
    EQUB 44:EQUB 43:EQUB 42:EQUB 41:EQUB 40
    EQUB 4:EQUB 3:EQUB 2:EQUB 1:EQUB 0
.slack_space
    
ORG &7680

.group_map
    EQUB&FF:EQUB&80:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&7F:EQUB&C0:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&3F:EQUB&E0:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&1F:EQUB&F0:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&0F:EQUB&F8:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&07:EQUB&FC:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&03:EQUB&FE:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&01:EQUB&FF:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&FF:EQUB&80:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08
    EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&00:EQUB&40:EQUB&20
    EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40
    EQUB&00:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00
    EQUB&80:EQUB&40:EQUB&20:EQUB&00:EQUB&10:EQUB&08:EQUB&04:EQUB&02
    EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&00:EQUB&08
    EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10
    EQUB&08:EQUB&00:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40
    EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&00:EQUB&02:EQUB&01:EQUB&00
    EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&00
    EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04
    EQUB&02:EQUB&01:EQUB&00:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10
    EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&E0:EQUB&70
    EQUB&38:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&1C:EQUB&0E:EQUB&07:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&03:EQUB&81:EQUB&C0:EQUB&E0
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&1C:EQUB&0E:EQUB&07:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&03:EQUB&81:EQUB&C0
    EQUB&E0:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&70:EQUB&38:EQUB&1C:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&03:EQUB&81
    EQUB&C0:EQUB&E0:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&70:EQUB&38:EQUB&1C:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&0E:EQUB&07:EQUB&03
    EQUB&80

ORG &7800

.vision_map
    EQUB&7F:EQUB&F0:EQUB&38:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01
    EQUB&00:EQUB&80:EQUB&5F:EQUB&F8:EQUB&1C:EQUB&04:EQUB&02:EQUB&01
    EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&37:EQUB&FC:EQUB&0E:EQUB&01
    EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&1D:EQUB&F1
    EQUB&C0:EQUB&E0:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02
    EQUB&0F:EQUB&78:EQUB&E0:EQUB&70:EQUB&10:EQUB&08:EQUB&04:EQUB&02
    EQUB&01:EQUB&00:EQUB&87:EQUB&DC:EQUB&70:EQUB&38:EQUB&04:EQUB&02
    EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&23:EQUB&F6:EQUB&07:EQUB&03
    EQUB&81:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&09:EQUB&FD
    EQUB&03:EQUB&81:EQUB&C0:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04
    EQUB&02:EQUB&FF:EQUB&01:EQUB&C0:EQUB&E0:EQUB&10:EQUB&08:EQUB&04
    EQUB&02:EQUB&01:EQUB&00:EQUB&F0:EQUB&1F:EQUB&FC:EQUB&08:EQUB&04
    EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&38:EQUB&17:EQUB&FE
    EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&1C
    EQUB&0D:EQUB&FF:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08
    EQUB&04:EQUB&01:EQUB&C7:EQUB&7C:EQUB&70:EQUB&20:EQUB&10:EQUB&08
    EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&E3:EQUB&DE:EQUB&38:EQUB&08
    EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&71:EQUB&F7
    EQUB&1C:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10
    EQUB&07:EQUB&FD:EQUB&81:EQUB&C0:EQUB&80:EQUB&40:EQUB&20:EQUB&10
    EQUB&08:EQUB&04:EQUB&03:EQUB&FF:EQUB&40:EQUB&E0:EQUB&20:EQUB&10
    EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&01:EQUB&FF:EQUB&C0:EQUB&70
    EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&78:EQUB&1C
    EQUB&07:EQUB&FC:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20
    EQUB&1C:EQUB&0E:EQUB&05:EQUB&FD:EQUB&00:EQUB&80:EQUB&40:EQUB&20
    EQUB&10:EQUB&08:EQUB&0E:EQUB&07:EQUB&03:EQUB&7E:EQUB&40:EQUB&20
    EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&00:EQUB&E0:EQUB&71:EQUB&DF
    EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&70
    EQUB&38:EQUB&F7:EQUB&84:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40
    EQUB&20:EQUB&38:EQUB&1C:EQUB&7D:EQUB&C1:EQUB&00:EQUB&80:EQUB&40
    EQUB&20:EQUB&10:EQUB&08:EQUB&03:EQUB&81:EQUB&FF:EQUB&60:EQUB&40
    EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&C0:EQUB&FF
    EQUB&D0:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80
    EQUB&E0:EQUB&7F:EQUB&F0:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80
    EQUB&40:EQUB&30:EQUB&08:EQUB&04:EQUB&01:EQUB&FF:EQUB&C0:EQUB&E0
    EQUB&40:EQUB&20:EQUB&10:EQUB&04:EQUB&02:EQUB&01:EQUB&01:EQUB&7F
    EQUB&E0:EQUB&70:EQUB&10:EQUB&08:EQUB&04:EQUB&01:EQUB&00:EQUB&80
    EQUB&40:EQUB&DF:EQUB&F0:EQUB&38:EQUB&04:EQUB&02:EQUB&01:EQUB&00
    EQUB&40:EQUB&20:EQUB&10:EQUB&77:EQUB&C7:EQUB&03:EQUB&81:EQUB&00
    EQUB&80:EQUB&40:EQUB&10:EQUB&08:EQUB&04:EQUB&3D:EQUB&E3:EQUB&81
    EQUB&C0:EQUB&40:EQUB&20:EQUB&10:EQUB&04:EQUB&02:EQUB&01:EQUB&1F
    EQUB&71:EQUB&C0:EQUB&E0:EQUB&10:EQUB&08:EQUB&04:EQUB&01:EQUB&00
    EQUB&80:EQUB&4F:EQUB&D8:EQUB&1C:EQUB&0E:EQUB&04:EQUB&02:EQUB&01
    EQUB&00:EQUB&40:EQUB&20:EQUB&17:EQUB&F4:EQUB&0E:EQUB&07:EQUB&01
    EQUB&00:EQUB&80:EQUB&40:EQUB&10:EQUB&08:EQUB&07:EQUB&FC:EQUB&07
    EQUB&03:EQUB&80:EQUB&40:EQUB&20:EQUB&18:EQUB&04:EQUB&02:EQUB&01
    EQUB&C0:EQUB&7F:EQUB&F0:EQUB&20:EQUB&10:EQUB&08:EQUB&02:EQUB&01
    EQUB&00:EQUB&80:EQUB&E0:EQUB&5F:EQUB&F8:EQUB&08:EQUB&04:EQUB&02
    EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&70:EQUB&37:EQUB&FC:EQUB&02
    EQUB&01:EQUB&00:EQUB&80:EQUB&20:EQUB&10:EQUB&08:EQUB&07:EQUB&1D
    EQUB&F1:EQUB&C0:EQUB&80:EQUB&40:EQUB&20:EQUB&08:EQUB&04:EQUB&02
    EQUB&03:EQUB&8F:EQUB&78:EQUB&E0:EQUB&20:EQUB&10:EQUB&08:EQUB&02
    EQUB&01:EQUB&00:EQUB&81:EQUB&C7:EQUB&DC:EQUB&70:EQUB&08:EQUB&04
    EQUB&02:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&1F:EQUB&F6:EQUB&07
    EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&20:EQUB&10:EQUB&08:EQUB&0F
    EQUB&FD:EQUB&03:EQUB&80:EQUB&80:EQUB&40:EQUB&20:EQUB&08:EQUB&04
    EQUB&02:EQUB&07:EQUB&FF:EQUB&01:EQUB&C0:EQUB&20:EQUB&10:EQUB&0C
    EQUB&02:EQUB&01:EQUB&00:EQUB&E0:EQUB&70:EQUB&1F:EQUB&F0:EQUB&08
    EQUB&04:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&70:EQUB&38:EQUB&17
    EQUB&F4:EQUB&02:EQUB&01:EQUB&00:EQUB&40:EQUB&20:EQUB&10:EQUB&38
    EQUB&1C:EQUB&0D:EQUB&F9:EQUB&00:EQUB&80:EQUB&40:EQUB&10:EQUB&08
    EQUB&04:EQUB&03:EQUB&81:EQUB&C7:EQUB&7C:EQUB&40:EQUB&20:EQUB&10
    EQUB&04:EQUB&02:EQUB&01:EQUB&01:EQUB&C0:EQUB&E3:EQUB&DE:EQUB&10
    EQUB&08:EQUB&04:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&E0:EQUB&71
    EQUB&F7:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&40:EQUB&20:EQUB&10
    EQUB&0E:EQUB&07:EQUB&FD:EQUB&81:EQUB&00:EQUB&80:EQUB&40:EQUB&10
    EQUB&08:EQUB&04:EQUB&07:EQUB&03:EQUB&FF:EQUB&40:EQUB&40:EQUB&20
    EQUB&10:EQUB&04:EQUB&02:EQUB&01:EQUB&03:EQUB&81:EQUB&FF:EQUB&C0
    EQUB&10:EQUB&08:EQUB&06:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20
    EQUB&10:EQUB&07:EQUB&FF:EQUB&03:EQUB&80:EQUB&80:EQUB&40:EQUB&20
    EQUB&10:EQUB&08:EQUB&04:EQUB&05:EQUB&FF:EQUB&81:EQUB&C0:EQUB&20
    EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&03:EQUB&7F:EQUB&C0
    EQUB&E0:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&41
    EQUB&DF:EQUB&1C:EQUB&0E:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40
    EQUB&20:EQUB&10:EQUB&F7:EQUB&8E:EQUB&07:EQUB&00:EQUB&80:EQUB&40
    EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&7D:EQUB&C7:EQUB&03:EQUB&80
    EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&3F:EQUB&60
    EQUB&70:EQUB&38:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80
    EQUB&5F:EQUB&D0:EQUB&38:EQUB&1C:EQUB&02:EQUB&01:EQUB&00:EQUB&80
    EQUB&40:EQUB&20:EQUB&1F:EQUB&F0:EQUB&1C:EQUB&0F:EQUB&00:EQUB&80
    EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&07:EQUB&01:EQUB&FF:EQUB&C0
    EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&03:EQUB&81
    EQUB&7F:EQUB&E0:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00
    EQUB&81:EQUB&C0:EQUB&DF:EQUB&F0:EQUB&04:EQUB&02:EQUB&01:EQUB&00
    EQUB&80:EQUB&40:EQUB&20:EQUB&1C:EQUB&77:EQUB&C7:EQUB&01:EQUB&00
    EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&0E:EQUB&3D:EQUB&E3
    EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&07
    EQUB&1F:EQUB&71:EQUB&C0:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01
    EQUB&00:EQUB&80:EQUB&7F:EQUB&D8:EQUB&1C:EQUB&04:EQUB&02:EQUB&01
    EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&3F:EQUB&F4:EQUB&0E:EQUB&01
    EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&1F:EQUB&FC
    EQUB&07:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&03
    EQUB&81:EQUB&C0:EQUB&7F:EQUB&A0:EQUB&10:EQUB&08:EQUB&04:EQUB&02
    EQUB&01:EQUB&01:EQUB&C0:EQUB&E0:EQUB&5F:EQUB&C8:EQUB&04:EQUB&02
    EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&E0:EQUB&70:EQUB&37:EQUB&E2
    EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&0E:EQUB&07
    EQUB&1D:EQUB&F0:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04
    EQUB&07:EQUB&03:EQUB&8F:EQUB&78:EQUB&20:EQUB&10:EQUB&08:EQUB&04
    EQUB&02:EQUB&01:EQUB&03:EQUB&81:EQUB&C7:EQUB&DC:EQUB&08:EQUB&04
    EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&38:EQUB&1F:EQUB&F6
    EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&1C
    EQUB&0F:EQUB&FD:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08
    EQUB&04:EQUB&0E:EQUB&07:EQUB&FF:EQUB&00

.code_end

cands_17        = vision_map + 821
cands_89v       = cands_17 + 81
cand_count      = cands_17 + 162

SAVE "M.SUDOKU0", code_begin, code_end, safe_return
