scr_ptr         = &70   \  Pointer to screen memory
see_ptr         = &72   \  Pointer to vision map
text_ptr        = &74   \  Text pointer for printing

set_ptr         = &76   \  Main set pointer
alt_ptr         = &78   \  Alternate set pointer for 2-way set operations

pos1            = &7C
pos2            = &7D
pos3            = &7E
pos4            = &7F

remainder       = &81   \  For dodgy fast division routine, or scratch
divisor         = &82
quotient        = &80

multiplier      = &80   \  For multiplication routine, or scratch
preload         = &82
multiplicand    = &84
product         = &80

tens            = &80
units           = &81
hundreds        = &82

tempX           = &86
tempY           = &87
pixelX          = &88   \  Pixel X co-ordinate 0..77
pixelY          = &89   \  Pixel Y co-ordinate 0..74  (0 is top of screen!)
fix_pos         = &8A   \  Fixed position to which we are comparing cells
var_pos         = &8B   \  Variable position of cell being compared
solved          = &8C   \  Number of solved digits in puzzle so far
digit           = &8D
cand_copy       = &8E   \  Copy of candidates for cell under consideration

\  BASIC VARIABLES

bas_var_S       = &44C

\  MOS ENTRY POINTS

osasci          = &FFE3
osnewl          = &FFE7
oswrch          = &FFEE

\  ERROR CODES

E_NOT_ALLOWED   = 51

\  SEEMS TO BE WORKING NOW
\  WILL COMMENT OUT DEBUGGING CODE FOR NOW RATHER THAN REMOVE IT ALTOGETHER
\  JUST IN CASE .....

GUARD &7C00
ORG &6000

.code_begin

.ext_reset_grid
    JMP reset_grid
.ext_set_digit
    JMP set_digit
.ext_set_pixel
    JMP set_pixel
.ext_clr_pixel
    JMP clr_pixel
.ext_show_seen
    JMP show_seen
.ext_test_solved
    JMP test_solved
.ext_test_candidate
    JMP test_candidate
.ext_eliminate_candidate
    JMP eliminate_candidate
.ext_disp_pos
    JMP disp_pos
.ext_disp_contents
    JMP disp_contents
.ext_get_see
    JMP get_see
.ext_clr_seen
    JMP clr_seen
.ext_elim_out
    JMP elim_out
.ext_reset_tally
    JMP reset_tally
.ext_update_tally
    JMP update_tally
.ext_show_instances
    JMP show_instances
.ext_get_set_cell
    JMP get_set_cell
.ext_set_set_cell
    JMP set_set_cell
.ext_clr_set_cell
    JMP clr_set_cell
.ext_show_set
    JMP show_set
.ext_tally_set
    JMP tally_set
.ext_fill_set
    JMP fill_set
.ext_elim_in
    JMP elim_in
.ext_elim_set
    JMP elim_set
.ext_dump_grid
    JMP dump_grid
.ext_count_solved
    JMP count_solved
.ext_clr_digit
    JMP clr_digit
.ext_write_digit
    JMP write_digit
.ext_init_alt_for_all
    JMP init_alt_for_all
.ext_show_alt
    JMP show_alt
.ext_and_alt_seen
    JMP and_alt_seen
.ext_test_alt
    JMP test_alt
.ext_get_alt_cell
    JMP get_alt_cell
.ext_and_alt_digit
    JMP and_alt_digit
.ext_init_alt_digit
    JMP init_alt_digit
.ext_elim_ext
    JMP elim_ext
.ext_disp_group
    JMP disp_group
.ext_eliminate_all
    JMP eliminate_all
.ext_init_set_candidate
    JMP init_set_candidate
.ext_tally_rows
    JMP tally_rows
.ext_tally_columns
    JMP tally_columns

\  BLUERIZLAGIRL'S SUPER FAST DIVISION SUBROUTINE
\
\  AS LONG AS WE ARE DIVIDING SOMETHING <= 255 BY AN ODD NUMBER, WE CAN
\  START WITH THE DIVISOR SHIFTED ALL THE WAY LEFT; TRY TO SUBTRACT IT
\  FROM THE DIVIDEND; SHIFT 1 OR 0 LEFT INTO QUOTIENT; SHIFT THE DIVISOR
\  RIGHT; AND KEEP GOING TILL 1 GETS SHIFTED OUT.

.divide_by_3
    LDY #&C0
    STY divisor
.fast_divide
    LDY #0
    STY quotient
.fd1
    TAY                 \  Save remainder in Y
    SEC
    SBC divisor
    BCS fd2             \  Skip restore if subtraction succeeded
    TYA                 \  Undo subtraction
.fd2
    ROL quotient        \  Shift in carry bit
    LSR divisor         \  Try subtracting in next lower place
    BCC fd1             \  Keep going till 1 drops out of the end
    TAY                 \  Return remainder in Y
    LDA quotient
    RTS
    
.mult16
    LDA #0
    STA product+3
    STA product+2
.mult16_preload
    \  Begin by shifting the multiplier right so its lowest bit is already
    \  in the carry flag.
    LDY #17             \  one more than we need
    BNE _mult16_3       \  always branches; A = 0
._mult16_1
    BCC _mult16_2
    \  Add the multiplicand to the high word of the product
    CLC
    LDA product+2
    ADC multiplicand
    STA product+2
    LDA product+3
    ADC multiplicand+1
    STA product+3
    \  Shift the product right
._mult16_2
    ROR product+3
    ROR product+2
._mult16_3
    ROR product+1
    ROR product
    \  See if we need to go around again
    DEY
    BNE _mult16_1
    RTS
    
.set_mulcnd
    STA multiplicand
    LDA #0
    STA multiplicand+1
    RTS
    
.alt_calc_see_pos
    STX preload
    STY multiplier
    LDA #81
    STA multiplicand
    LDA #0
    STA multiplier+1
    STA preload+1
    STA multiplicand+1
    JSR mult16_preload
    LDA product
    LDX product+1
    RTS

\  CALCULATE SCREEN ADDRESS FROM DIGIT POSITION
\  ON ENTRY X, Y GIVE DIGIT POSITION
\  A IS PRESERVED 

.calc_digit_pos
    PHA
    STY scr_ptr             \  Place copy of Y co-ordinate in pointer
    LDA #0
    STA scr_ptr+1
    TYA                 \  Work with Y co-ordinate in A
    ASL  A
    ASL  A              \  Now A = Y * 4
    CLC                 \  No harm in making sure
    ADC scr_ptr         \  Add the copy we saved earlier
    STA scr_ptr         \  Now [scr_ptr] = Y * 5 ; max. value = 40
    ASL scr_ptr
    ASL scr_ptr
    ASL scr_ptr         \  max. value = 320 -- may set C
    ROL scr_ptr+1
    ASL scr_ptr
    ROL scr_ptr+1       \  Now [scr_ptr, scr_ptr+1] = Y * 80
    TXA                 \  Work with X co-ordinate in A
    ASL  A
    ASL  A              \  Now A = X * 4
    CLC
    ADC scr_ptr
    STA scr_ptr
    BCC _cdp1           \  Skip if no carry
    INC scr_ptr+1       \  Now [scr_ptr, scr_ptr+1] = Y * 80 + X * 4
._cdp1
    CLC                 \  Add beginning of screen to [scr_ptr, scr_ptr+1]
    LDA #&7C
    ADC scr_ptr+1
    STA scr_ptr+1
    PLA                 \  Retrieve the value saved earlier
.safe_return
    RTS
    
\  WRITE DIGIT A IN POSITION (X, Y)
\
\  On entry X => X co-ordinate in main grid
\           Y => Y co-ordinate in main grid
\           A = Digit to write; 0 erases digit

.write_digit
    JSR calc_digit_pos
    ASL  A
    ASL  A              \  Now A = digit * 4
    TAX                 \  This is index into table.
    LDY #1
    JSR digit_row
    JSR digit_row2
    LDY #41
    JSR digit_row
.digit_row2
    LDA #&20
    STA (scr_ptr),Y
    RTS
.digit_row
    JSR digit_row1
.digit_row1
    LDA digit_patt,X
    INX
    STA (scr_ptr),Y
    INY
    RTS
    
\  CALCULATE SCREEN ADDRESS FOR PENCIL MARK POSITION
\  Pencil marks are a 3*3 grid of dots
\
\   1  2  3
\   4  5  6
\   7  8  9
\
\  On entry X => X co-ordinate in main grid
\           Y => Y co-ordinate in main grid

.calc_pmk_pos
    JSR calc_digit_pos
    STA &72             \  Save copy of A
    ASL  A              \  Multiply by 2
    ADC &72             \  Add copy to get 3 * digit
    ASL  A              \  Double to get 6 * digit
    TAX
    LDY #1
    RTS

\  SET A PENCIL MARK
    
.set_pmk
    JSR calc_pmk_pos
    JSR set_row
    LDY #41             \  Beginning of second row
.set_row                \  Set row of pixel pattern for digit
    JSR set_row1
    JSR set_row1
.set_row1
    LDA (scr_ptr),Y
    ORA pmk_patt,X
    JMP pmk_write

\  CLEAR A PENCIL MARK

.clr_pmk
    JSR calc_pmk_pos
    JSR clr_row
    LDY #41             \  Beginning of second row
.clr_row                \  Unset row of pixel pattern for digit
    JSR clr_row1
    JSR clr_row1
.clr_row1
    LDA (scr_ptr),Y
    ORA pmk_patt,X      \  Setting and inverting just the bit we want is
    EOR pmk_patt,X      \  quicker than inverting it to create a mask
    JMP pmk_write
    
\  TOGGLE A PENCIL MARK ON <-> OFF

.toggle_pmk
    JSR calc_pmk_pos
    JSR toggle_row
    LDY #41             \  Beginning of second row
.toggle_row             \  EOR pixel pattern row for digit with screen
    JSR toggle_row1
    JSR toggle_row1
.toggle_row1
    LDA (scr_ptr),Y
    EOR pmk_patt,X
.pmk_write
    INX                 \  Next position in pattern
    STA (scr_ptr),Y
    INY                 \  Next position on screen
    RTS

.set_digit_colour
    JSR calc_digit_pos
    AND #&07
    BNE _sdc_not0
    LDA #7
._sdc_not0
    ORA #&90            \  Set graphics colour
    LDY #0
    STA (scr_ptr), Y
    LDY #40
    STA (scr_ptr), Y
    RTS

.calc_see_pos
    STX preload         \  Begin with X in preload ...
    STY multiplier      \  ... Y in multiplier ...
    LDA #81             \  ... 81 in multiplicand
    STA multiplicand
    LDA #0              \  All high bytes are 0 
    STA multiplier+1
    STA preload+1
    STA multiplicand+1
    JSR mult16_preload
    LDA product
    AND #&07            \  Equivalent to MOD 8
    TAX                 \  Now X holds position MOD 8
    LSR product+1
    ROR product
    LSR product+1
    ROR product
    LSR product+1
    ROR product         \  Equivalent to DIV 8
    CLC
    LDA product
    ADC #vision_map MOD256
    STA see_ptr
    LDA product+1
    ADC #vision_map DIV256
    STA see_ptr+1
    LDY #0
    LDA (see_ptr), Y
    RTS
    
.get_see
    JSR calc_see_pos
    AND bits_HL, X
    RTS
    
.set_see
    JSR calc_see_pos
    ORA bits_HL, X
    BNE _clr_see1       \  Always branches
.clr_see
    JSR calc_see_pos
    ORA bits_HL, X      \  Set it
    EOR bits_HL, X      \  Toggle it
._clr_see1
    STA (see_ptr), Y
    RTS

.set_pixel
    JSR get_pixel_pos
    ORA (scr_ptr), Y
    STA (scr_ptr), Y
    RTS
.clr_pixel
    JSR get_pixel_pos
    EOR #&FF
    AND (scr_ptr), Y
    STA (scr_ptr), Y
    RTS
    
\  GET PIXEL POSITION
\
\  Expects X = 0 .. 77 and Y = 0 .. 74  (NB: 0 is at top!)
\
\  On return, scr_ptr points to screen location
\             A = bit mask for pixel within character cell

.get_pixel_pos
    TYA                 \  Prepare to divide Y co-ordinate by 3
    LDY #0              \  Clear high byte of screen pointer
    STY scr_ptr+1
    JSR divide_by_3     \  Now A = answer, Y = remainder
    STA scr_ptr         \  Save a copy of (Y DIV 3)
    ASL A
    ASL A
    CLC
    ADC scr_ptr         \  Now [scr_ptr] = 5 * (Y DIV 3) ; max. = 120
    STA scr_ptr
    ASL scr_ptr         \  Max. value = 240
    ASL scr_ptr         \  This one might generate a carry
    ROL scr_ptr+1
    ASL scr_ptr
    ROL scr_ptr+1       \  Now [scr_ptr] = 40 * (Y DIV 3) ; max. = 960
    TXA                 \  X co-ordinate 0..77
    LSR A               \  Halve it, shifting LSB into carry
    PHP                 \  Save carry flag for later
    SEC                 \  Add extra 1 to skip graphics colour ctrl code
    ADC scr_ptr         \  Add horizontal character position
    STA scr_ptr         \  Now [scr_ptr] = 40 * (Y DIV 3) + (X DIV 2) + 1
    LDA scr_ptr+1
    ADC #&7C            \  Add high byte of address of start of screen
    STA scr_ptr+1
    PLP                 \  Retrieve carry flag => old lowest bit of X
    BCC _gpp_lhs        \  Skip for a pixel on the left-hand side
._gpp_rhs
    INY
    INY
    INY                 \  Now we point to right-hand pixel value
._gpp_lhs
    LDA lh_pixels, Y    \  
    LDY #0
    RTS

.lh_pixels
    EQUB &01:EQUB &04:EQUB &10
.rh_pixels
    EQUB &02:EQUB &08:EQUB &40

.show_seen
    STX fix_pos
    STY pixelY
    LDA #0
    STA var_pos
._ss_row
    LDA #68
    STA pixelX
._ss_col
    LDX fix_pos
    LDY var_pos
    JSR get_see
    PHP                 \  Save Z flag for later
    LDX pixelX
    LDY pixelY
    PLP                 \  Retrieve Z flag
    BEQ _ss_0
    JSR set_pixel
    BNE _ss_next        \  Will always branch
._ss_0
    JSR clr_pixel
._ss_next
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #77
    BCC _ss_col
    INC pixelY
    LDA var_pos
    CMP #81
    BCC _ss_row
    RTS

.clr_seen
    LDX #68
    JSR get_pixel_pos   \  Now [scr_ptr] is set
    LDX #14    
.cs_char
    LDA map_pos, X
    TAY
    LDA #32
    STA (scr_ptr), Y
    DEX
    BPL cs_char
    RTS

\  RESET THE GRID TO COMPLETELY EMPTY
\
\  BIT PATTERN FOR EACH CELL IN THE GRID IS INITIALLY AS FOLLOWS;
\
\  cands_17, X          cands_89v, X
\           01111111            11000000
\           ||||||||            ||  ||||
\           |1|3|5|7            |9  `--'
\           | 2 4 6             8   value
\      solved

.reset_grid
    LDX #0
    STX solved          \  No digits solved to begin with
._rsg_0
    LDA #&7F
    STA cands_17, X     \  01111111 => Not solved, can be 1-7
    LDA #&C0
    STA cands_89v, X    \  11000000 => Can be 8-9
    INX
    CPX #81
    BCC _rsg_0
    RTS
    
\  TEST WHETHER A CANDIDATE IS ALLOWED IN A CELL
\  X => CELL TO TEST
\  A => CANDIDATE TO TEST FOR

.test_candidate
    TAY                 \  Candidate for which we are testing
.test_cand_Y
    CPY #8              \  See which byte candidate belongs to
    BCS _tc_89
._tc_17
    LDA cands_17, X     \  Byte with candidates 1-7
    AND bits_HL, Y      \  AND with bit for candidate
    RTS
._tc_89
    LDA cands_89v, X    \  Byte with candidates 8-9 and value
    AND bits_HL-8, Y    \  AND with bit for candidate
    RTS

\  ELIMINATE A CANDIDATE FROM A CELL
\  X => CELL TO ELIMINATE FROM
\  A => CANDIDATE TO ELIMINATE

.eliminate_candidate
    CLV                 \  V=0 => not naked single
    TAY                 \  Save the candidate
\    LDA #33             \  "!"
\    JSR oswrch
\    TXA
\    PHA
\    TYA
\    JSR disp_digit      \  Digit being eliminated
\    PLA
\    TAX
\    JSR disp_hex_cands  \  Hex rep of destination and candidates
\    JSR osnewl
    LDA cands_17, X
    BPL _ec_not_solved  \  Exit if already solved
._ec_never_set
    SEC                 \  C=1 => candidate was never allowed
    RTS
._ec_not_solved
    CPY #8
    BCS _ec_89
._ec_17
    AND bits_HL, Y
    BEQ _ec_never_set   \  Exit if candidate was never allowed
    LDA cands_17, X     \  Byte with candidates 1-7
    ORA bits_HL, Y
    EOR bits_HL, Y
    STA cands_17, X     \  Store new candidates
    JMP _ec_done
._ec_89
    LDA cands_89v, X    \  Byte with candidates 8-9
    AND bits_HL-8, Y
    BEQ _ec_never_set
    LDA cands_89v, X    \  Byte with candidates 8-9
    ORA bits_HL-8, Y
    EOR bits_HL-8, Y
    STA cands_89v, X    \  Store new candidates
._ec_done

    TXA
    PHA
    TAX
    JSR disp_pos
    JSR say
    EQUS " cannot be "
    BRK
    TYA
    JSR disp_digit
    LDA #46             \  "."
    JSR oswrch
    JSR osnewl
    PLA
    TAX
    JSR disp_contents
    
    CLV                 \  V=0 => not naked single
    CLC                 \  C=0 => candidate successfully eliminated
    
    \  MAKE SURE SOME CANDIDATES ARE STILL ALLOWED.
    \  IF ONLY ONE REMAINS -- CONSIDER CELL SOLVED
    
._ec_count_cands
    \TXA
    \PHA
    \JSR disp_pos
    \JSR say
    \EQUS " can be:"
    \BRK
    \PLA
    \TAX
    JSR count_cands
    CMP #1
    BNE _ctc_not_naked
._ctc_naked
    \  ONLY ONE POSSIBLE CANDIDATE REMAINS = NAKED SINGLE!
    \  DIGIT VALUE MUST BE IN preload
    \LDA #&80
    \STA cands_17, X     \  Set "solved" bit
    \LDA preload
    \STA cands_89v, X    \  Store cell value
    \INC solved          \  Increase solved count
    \JSR _ctc_naked1
    
    TXA
    PHA
    LDA preload
    JSR set_digit
    PLA
    PHA
    TAX
    
    \   TXA             \  done other way round now
    \   PHA
    JSR disp_pos
    JSR say
    EQUS " can only contain "
    BRK
    LDA preload
    JSR disp_digit
    LDA #33             \  "!"
    JSR oswrch
    JSR osnewl
    PLA
    TAX
    JSR disp_contents
    
\  NO!  DON'T TRY TO CHASE THIS UP YET!  WE HAVE NOT YET DONE ALL THE
\  CONSEQUENT ELIMINATIONS.  

    \LDA digit
    \PHA
    \TXA
    \PHA
    \LDA cands_89v, X
    \JSR elim_out
    \PLA
    \TAX
    \PLA
    \STA digit
    
    LDY preload
    BIT _ctc_rts        \  This will set V=1 => cell now solved
    RTS
._ctc_not_naked
    CLV                 \  V=0 => not naked single
    CLC                 \  C=0 => successful elimination, A is count
._ctc_rts
    RTS
        
.count_cands
    JSR copy_cands
    LDA #0
    STA multiplier      \  Use this to count allowed digits
    STA preload         \  This is initially 0
    LDY #1              \  Digit we are testing for
    JSR asl_cand_copy   \  Skip "solved" bit
._ncc_digit
    JSR asl_cand_copy
    BCC _ncc_not_allowed
    INC multiplier      \  Increase count of digits allowed
    STY preload         \  Update highest allowed digit
    \TYA
    \JSR disp_digit
._ncc_not_allowed
    INY
    CPY #10
    BCC _ncc_digit
    \LDA #46
    \JSR oswrch
    \LDA multiplier      \  Return count of candidates allowed
    \JSR disp_digit_sp
    \JSR say
    \EQUS "left."
    \BRK
    \JSR osnewl
    LDA multiplier      \  Return count of candidates allowed    
    RTS
    
.copy_cands
    LDA cands_17, X
    STA cand_copy
    LDA cands_89v, X
    STA cand_copy+1
    RTS

\  SET A DIGIT TO A DEFINITE VALUE

.set_digit
    JSR test_candidate
    BNE _sd_1
    BRK
    EQUB E_NOT_ALLOWED
    EQUS "Not allowed"
    BRK
._sd_1
    LDA #&80
    STA cands_17, X     \  Bit 7=1 => cell is solved
    TYA
    STA cands_89v, X    \  Solved digit value
    INC solved
    RTS
    
\  CLEAR A DIGIT VALUE

.clr_digit
    LDA cands_17, X     \  See if cell is already solved ...
    BPL _cdt_0          \  ... Skip if not
    DEC solved          \  Decrease count of solved digits
._cdt_0
    LDA #&7F            \  Unsolved; can be 1, 2, 3, 4, 5, 6, 7
    STA cands_17, X
    LDA #&C0            \  can be 8, 9
    STA cands_89v, X
    RTS
    
\  COUNT UP SOLVED DIGITS

.count_solved
    LDX #0
    STX solved          \  Start with no digits solved
._csd_0
    LDA cands_17, X     \  Test whether cell is solved
    AND #&80            \  Bit 7 => solved
    BEQ _csd_1          \  Skip if not solved
    INC solved          \  Increase count of solved digits
._csd_1
    INX                 \  Move onto next cell
    CPX #81
    BCC _csd_0          \  Go round again if any more cells untested
    RTS

\  CONVERT A CELL POSITION 0..80 IN A OR X TO A PAIR OF CO-ORDINATES
\  WHICH WILL BE RETURNED IN X AND Y

.conv_xy                \  Position is in A to begin with
    TAX
.conv_xyX               \  Position is already in X
    LDA xy_coords, X    \  Now high nybble = Y, low nybble = X
    TAX
    JSR lsra4           \  Shift down high nybble ...
    TAY                 \  ... giving Y co-ordinate
    TXA
    AND #&0F            \  Mask out Y co-ordinate in high nybble ...
    TAX                 \  ... leaving X co-ordinate
    RTS

\  SHIFT ACCUMULATOR RIGHT 4 PLACES
\  (4 bytes + RTS, but a JSR here is only 3 bytes)
    
.lsra4
    LSR A
    LSR A
    LSR A
    LSR A
    RTS

\  CONVERT A CELL POSITION 0..80 TO A HUMAN-READABLE ROW AND COLUMN
\  E.G.  0 => R1C1, 12 => R2C4, 40 => R5C5, 63 => R7C1, 80 => R9C9
\  POSITION SHOULD BE IN X
\  PRESERVES A, X AND Y
    
.disp_pos
    PHA
    TYA
    PHA
    TXA
    PHA
    JSR conv_xyX
    LDA #&52            \  "R"
    JSR oswrch
    TYA
    SEC                 \  display row number starting from 1
    ADC #&30            \  ASCII code for 0
    JSR oswrch
    LDA #&43            \  "C"
    JSR oswrch
    TXA
    SEC                 \  display column number starting from 1
    ADC #&30
    JSR oswrch
    PLA
    TAX
    PLA
    TAY
    PLA
    RTS

\  EXTENDED VERSION; DISPLAYS THE POSITION AND ITS CANDIDATE DIGITS
\  CARE: USES EVEN MORE STACK!

.disp_pos_ext
    PHA
    TYA
    PHA
    TXA
    PHA
    
    JSR conv_xyX
    LDA #&52            \  "R"
    JSR oswrch
    TYA
    SEC                 \  display row number starting from 1
    ADC #&30            \  ASCII code for 0
    JSR oswrch
    LDA #&43            \  "C"
    JSR oswrch
    TXA
    SEC                 \  display column number starting from 1
    ADC #&30
    JSR oswrch
    LDA #61             \  =
    JSR oswrch
    
    TSX
    LDA &101, X         \  This will give X we pushed
    TAX
    
    LDA cand_copy       \  Save the copy of the candidates ...
    PHA
    LDA cand_copy+1
    PHA
    
    JSR copy_cands      \  ... which will get trashed
    LDY #1              \  Digit we are testing for
    JSR asl_cand_copy   \  Skip "solved" bit
._dpe_digit    
    JSR asl_cand_copy
    BCC _dpe_not_allowed
    TYA
    JSR disp_digit
._dpe_not_allowed
    INY
    CPY #9
    BCC _dpe_digit
    LDA #46
    JSR oswrch

    PLA                 \  Restore copy of candidates
    STA cand_copy+1
    PLA
    STA cand_copy

    PLA
    TAX
    PLA
    TAY
    PLA
    RTS

\  DISPLAY THE CONTENTS OF A CELL; EITHER AS A DIGIT IF IT IS SOLVED, OR
\  AS A CONSTELLATION OF PENCIL MARKS IF IT IS NOT YET SOLVED.

.disp_contents
    PHA
    TYA
    PHA
    TXA
    PHA
    LDA digit
    PHA
    JSR copy_cands
    JSR conv_xyX        \  Now X, Y hold co-ords
    BIT cand_copy       \  Bit 7 = 1 => solved
    BPL _dcc_pmark
._dcc_digit
    LDA cand_copy+1     \  Solved digit value
    JSR write_digit
    JMP _dcc_end
._dcc_pmark
    STX tempX           \  Save X co-ordinate
    STY tempY           \  Save Y co-ordinate
    JSR asl_cand_copy   \  Avoid a useless first trip around the loop
    LDA #1
    STA digit
._dcc_test
    JSR asl_cand_copy
    BCC _dcc_pmk_0
    JSR set_pmk
    JMP _dcc_next
._dcc_pmk_0
    JSR clr_pmk
._dcc_next
    INC digit
    LDA digit
    LDX tempX           \  Retrieve X co-ordinate
    LDY tempY           \  Retrieve Y co-ordinate
    CMP #10
    BCC _dcc_test       \  Test next candidate
._dcc_end
    PLA
    STA digit
    PLA
    TAX
    PLA
    TAY
    PLA
    RTS

\  TAKE A TALLY OF DIGITS WITHIN A SET
\
\  
    
.reset_tally
    LDX #9
    LDA #0
._ccc_1
    STA cand_count, X
    DEX
    BPL _ccc_1
    RTS

.update_tally
    LDA cands_17, X
    STA cand_copy       \  Make copy of allowed candidates
    BPL _udt_not_solved
    INC cand_count      \  Count of "zeros" is count of solved digits
    CLC                 \  C=0 => was already solved
    RTS
._udt_not_solved
    LDA cands_89v, X
    STA cand_copy+1
    LDX #0              \  First pass will do nothing, but the saving in
._udt_test_digit        \  cycles is hardly worth the extra bytes.
    JSR asl_cand_copy   \  Now C=1 => candidate was allowed
    BCC _udt_not_allowed
    INC cand_count, X   \  Increase count of allowed digit
._udt_not_allowed
    INX
    CPX #10
    BCC _udt_test_digit
    RTS                 \  With C=1
.asl_cand_copy
    ASL cand_copy+1
    ROL cand_copy
    RTS
    
\  TEST WHETHER A CANDIDATE IS ALLOWED IN A CELL
\  X => CELL TO TEST
\  ON RETURN A=0 => NOT SOLVED
\            A>0 => CELL VALUE

.test_solved
    TAY                 \  Save the candidate
    LDA cands_17, X     \  Bit 7=1 => is solved
    BMI _tsv_solved
    LDA #0              \  Z=1; will cause BEQ to branch
    RTS
._tsv_solved
    LDA cands_89v, X    \  Contains solved value
    RTS
    
\  ELIMINATE CANDIDATES FROM CELLS, WORKING OUTWARDS
\  THIS IS SAFELY RE-ENTRANT, SO WE CAN CHASE UP NAKED SINGLES

\  ORIGINAL BASIC
\
\ 5100DEFPROCman_elim_out(I%,D%)
\ 5110LOCALJ%,E%
\ 5112PRINT"Showing contents of ";:PROCdisp_pos(I%):PRINT
\ 5114PROCdisp_cont(I%)
\ 5120FORJ%=0TO80
\ 5130IFJ%=I%GOTO5190
\ 5140IFFNsee(I%,J%)=0GOTO5190
\ 5150IFFNsolved(J%)GOTO5190
\ 5160E%=FNelim_cand(J%,D%)
\ 5170IF(E%AND&1000000)=0PRINT;D%;" in ";:PROCdisp_pos(I%):PRINT" sees ";:PROCdisp_pos(J%):PRINT
\ 5180PROCdisp_cont(J%)
\ 5190NEXT
\ 5200ENDPROC
    
.elim_out

\ 5100DEFPROCman_elim_out(I%,D%)
\ 5110LOCALJ%,E%

    STA digit
    LDA fix_pos
    PHA
    LDA var_pos
    PHA

\ 5112PRINT"Showing contents of ";:PROCdisp_pos(I%):PRINT
\ 5114PROCdisp_cont(I%)

    STX fix_pos
    \JSR say
    \EQUS "Eliminating outwards from "
    \BRK
    \LDA digit
    \JSR disp_digit_sp
    \JSR say
    \EQUS "in "
    \BRK
    \LDX fix_pos
    \JSR disp_pos
    \LDA #58             \  colon
    \JSR oswrch
    \JSR osnewl
    LDY #66
    JSR show_seen
    LDX fix_pos
    JSR disp_contents

\ 5120FORJ%=0TO80

    LDX #0
    STX var_pos
._neo_test

\ 5130IFJ%=I%GOTO5190

    CPX fix_pos
    BEQ _neo_no_elim    \  No elimination from same cell
    
\ 5140IFFNsee(I%,J%)=0GOTO5190

    LDY fix_pos
    JSR get_see
    BEQ _neo_no_elim    \  No elimination if does not see

\ 5150IFFNsolved(J%)GOTO5190
\ 5160E%=FNelim_cand(J%,D%)

    LDX fix_pos
    LDA cands_89v, X    \  The digit in the fixed position ...
    LDX var_pos         \  ... gets eliminated from the variable position
    JSR eliminate_candidate
    
    BCS _neo_no_elim    \  No elimination if never allowed
    BCS _neo_miss       \  No elimination if never allowed

._neo_hit
    BVC _neo_not_naked
    BVS _neo_not_naked

.neo_naked_error
    BRK
    EQUB 56
    EQUS "Naked single"
    BRK
    
\ 5170IF(E%AND&1000000)=0PRINT;D%;" in ";:PROCdisp_pos(I%):PRINT" sees ";:PROCdisp_pos(J%):PRINT

._neo_not_naked

\ 5180PROCdisp_cont(J%)

    LDX var_pos
    JSR disp_contents

\ 5190NEXT

._neo_no_elim
    INC var_pos
    LDX var_pos
    CPX #81
    BCC _neo_test

\ 5200ENDPROC

    PLA
    STA var_pos
    PLA
    STA fix_pos
    RTS
    
._neo_miss
    LDX fix_pos
    LDA cands_89v, X
    ADC #47             \  We know C=1 here
    JSR oswrch
    JSR say
    EQUS " in "
    BRK
    LDX fix_pos
    JSR disp_pos
    JSR say
    EQUS " misses "
    BRK
    LDX var_pos
    JSR disp_pos
    JSR osnewl
    JMP _neo_no_elim

\  ELIMINATE CANDIDATES FROM A CELL, WORKING INWARDS
\  SAFELY RE-ENTRANT

.elim_in
    LDA fix_pos         \  Save fixed and variable positions
    PHA                 \  (which we are going to stomp on)
    LDA var_pos
    PHA

    STX fix_pos
    LDY #66
    JSR show_seen

    LDX #0
    STX var_pos
    
._nei_test
    CPX fix_pos         \  Skip if same position
    BEQ _nei_no_elim
    LDY fix_pos
    JSR get_see
    BEQ _nei_no_elim    \  No elimination if does not see
    LDX var_pos
    JSR test_solved     \  See if digit is solved
    BEQ _nei_no_elim
    
    STA digit           \  Remember digit for later
    LDX fix_pos
    JSR eliminate_candidate
    BCS _nei_no_elim
    JSR _nei_elim       \  Display message about elimination
    
    LDX var_pos
    BVC _nei_not_naked
    
    JSR say
    EQUS "Naked single"
    BRK
    JSR osnewl
    
    LDA #80             \  Jump to end of grid
    STA var_pos
    
._nei_not_naked
    LDX fix_pos
    JSR disp_contents
    
._nei_no_elim
    INC var_pos
    LDX var_pos
    CPX #81
    BCC _nei_test
    
    PLA                 \  Restore the previous positions
    STA var_pos
    PLA
    STA fix_pos
    RTS
    
._nei_elim
    PHP
    PHA
    TYA
    PHA
    TXA
    PHA
    
    LDX fix_pos         \  Display fixed position
    JSR disp_pos
    JSR say
    EQUS " sees "
    BRK
    LDA digit           \  Display digit in seen cell
    JSR disp_digit_sp
    JSR say
    EQUS "in "
    BRK
    LDX var_pos         \  Display variable position
    JSR disp_pos
    JSR osnewl
    
    PLA
    TAX
    PLA
    TAY
    PLA
    PLP
    RTS

\  SHOW ALL INSTANCES OF A CANDIDATE

.show_instances
    STX digit
    STY pixelY
    LDA #0
    STA var_pos
._shi_row
    LDA #68
    STA pixelX
._shi_col
    LDX var_pos
    JSR test_solved
    BNE _shi_0
    LDY digit
    JSR test_cand_Y
    BEQ _shi_0
    LDX pixelX
    LDY pixelY
    JSR set_pixel
    BNE _shi_next       \  Will always branch
._shi_0
    LDX pixelX
    LDY pixelY
    JSR clr_pixel
._shi_next
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #77
    BCC _shi_col
    INC pixelY
    LDA var_pos
    CMP #81
    BCC _shi_row
    RTS

\  CONVERT A BIT OFFSET IN Y, TO A BYTE OFFSET IN Y AND A SUB-OFFSET
\  TO A BIT WITHIN THAT BYTE IN X
    
.calc_set_ofs
    TYA                 \  Copy Y to accumulator
    TAX                 \  Also make a copy in X
    LSR A               \  Divide by 8 ...
    LSR A
    LSR A
    TAY                 \  ... and store in Y
    TXA                 \  Retrieve copy
    AND #7              \  Get remainder modulo 8 ...
    TAX                 \  ... and store in X
    RTS
    
.get_set_cell
    JSR calc_set_ofs
    LDA (set_ptr), Y
    AND bits_HL, X      \  Z=0 => bit was 1
    RTS

.set_set_cell
    JSR calc_set_ofs
    LDA (set_ptr), Y
    ORA bits_HL, X
    STA (set_ptr), Y
    RTS

.clr_set_cell
    JSR calc_set_ofs
    LDA (set_ptr), Y
    ORA bits_HL, X      \  force it to 1 ...
    EOR bits_HL, X      \  ... then invert it
    STA (set_ptr), Y
    RTS

\  SHOW THE IN/OUT STATUS OF A SET OF GRID SQUARES
\  ON ENTRY Y = VERTICAL POSITION
\           set-ptr,set_ptr+1 => SET TO DISPLAY

.show_set
    STY pixelY
    LDA #0
    STA var_pos
._shs_row
    LDA #68
    STA pixelX
._shs_col
    LDY var_pos
    JSR get_set_cell
    PHP                 \  Save Z flag for later
    LDX pixelX
    LDY pixelY
    PLP                 \  Retrieve Z flag
    BEQ _shs_0
    JSR set_pixel
    BNE _shs_next       \  Will always branch
._shs_0
    JSR clr_pixel
._shs_next
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #77
    BCC _shs_col
    INC pixelY
    LDA var_pos
    CMP #81
    BCC _shs_row
    RTS

\  TEST WHETHER A CELL IS WITHIN THE ALTERNATE SET
\  ON RETURN Z=1 => CELL WAS NOT IN ALT SET
    
.get_alt_cell
    JSR calc_set_ofs    \  This works the same either way
    LDA (alt_ptr), Y
    AND bits_HL, X      \  Z=0 => bit was 1
    RTS

.set_alt_cell
    JSR calc_set_ofs
    LDA (alt_ptr), Y
    ORA bits_HL, X
    STA (alt_ptr), Y
    RTS

.clr_alt_cell
    JSR calc_set_ofs
    LDA (alt_ptr), Y
    ORA bits_HL, X      \  force it to 1 ...
    EOR bits_HL, X      \  ... then invert it
    STA (alt_ptr), Y
    RTS

.show_alt_66
    LDY #66             \  Usual position where we want to show this
    
\  SHOW THE IN/OUT STATUS OF THE ALTERNATE SET OF GRID SQUARES
\  ON ENTRY Y = VERTICAL POSITION
\           alt-ptr,alt_ptr+1 => SET TO DISPLAY

.show_alt
    LDA var_pos
    PHA
    STY pixelY
    LDA #0
    STA var_pos
._sha_row
    LDA #68
    STA pixelX
._sha_col
    LDY var_pos
    JSR get_alt_cell
    PHP                 \  Save Z flag for later
    LDX pixelX
    LDY pixelY
    PLP                 \  Retrieve Z flag
    BEQ _sha_0
    JSR set_pixel
    BNE _sha_next       \  Will always branch
._sha_0
    JSR clr_pixel
._sha_next
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #77
    BCC _sha_col
    INC pixelY
    LDA var_pos
    CMP #81
    BCC _sha_row
    PLA
    STA var_pos
    RTS
    
\  TAKE THE INTERSECTION OF THE ALTERNATE SET WITH WHATEVER IS SEEN BY
\  A POSITION GIVEN IN X

.and_alt_seen
    LDA fix_pos
    PHA
    LDA var_pos
    PHA
    STX fix_pos         \  The digit we care what sees    
    LDA #0
    STA var_pos
    TAX
._aas_0
    LDY fix_pos
    JSR get_see
    BNE _aas_1          \  Skip if cells see each other
    LDY var_pos
    JSR clr_alt_cell    \  Clear cell if it was not seen
._aas_1
    INC var_pos
    LDX var_pos
    CPX #81             \  See if we have reached end
    BCC _aas_0
._aas_done
    PLA
    STA var_pos
    PLA
    STA fix_pos
    RTS

    
\  TALLY UP THE POSSIBLE CANDIDATES FOR THE CELLS IN A SET
\  ON RETURN; cand_count     => SOLVED CELLS
\             cand_count + 1 => POSSIBLE 1S
\             cand_count + 2 => POSSIBLE 2S
\               ...
\             cand_count + 9 => POSSIBLE 9S
\  SOLVED CELLS DO NOT COUNT TOWARDS CANDIDATE COUNTS!
\  IF A DIGIT CAN GO IN ONLY ONE CELL, WE NEED TO PUT
\  IT THERE!

.tally_set
    JSR reset_tally     \  This will leave 0 in A
    STA var_pos
\    JSR say
\    EQUS "Tallying "
\    BRK
\    JSR disp_group
\    LDA #58             \  colon
\    JSR oswrch
    
._tys_pos
    LDY var_pos
    JSR get_set_cell    \  See if cell is in set
    BEQ _tys_not_in     \  Skip if not in set
    LDX var_pos
    JSR update_tally
._tys_not_in
    INC var_pos
    LDA var_pos
    CMP #81
    BCC _tys_pos
    RTS
\    LDX #0
\._tys_disp
\    LDA cand_count, X
\    JSR disp_digit
\    CPX #9
\    BCS _tys_done
\    LDA #32
\    JSR oswrch
\    INX
\    BNE _tys_disp
\._tys_done
\    JMP osnewl

.fill_set
    STA digit
    LDX #0
    STX var_pos
._fis_pos
    LDY var_pos
    JSR get_set_cell    \  See if cell is in set
    \JSR _fis_dbg
    BEQ _fis_not_in     \  Skip if not in set
    
    LDX var_pos
    LDA digit
    JSR test_candidate
    BEQ _fis_not_in

    LDA digit
    \CLC
    \ADC #48
    \JSR oswrch
    JSR disp_digit
    JSR say
    EQUS " in "
    BRK
    JSR disp_group
    JSR say
    EQUS " can only go in "
    BRK
    LDX var_pos
    JSR disp_pos
    LDA #33             \  "!"
    JSR oswrch
    JSR osnewl
    
    LDA digit
    LDX var_pos
    JSR set_digit
    JSR disp_contents
    LDA digit
    LDX var_pos
    JSR elim_out
._fis_not_in
    LDA solved          \  Terminate loop early if puzzle is finished
    CMP #81
    BCS _fis_done
    INC var_pos
    LDX var_pos
    CPX #81
    BCC _fis_pos
._fis_done
    RTS
    
._fis_dbg
    PHP
    LDX var_pos
    JSR disp_pos
    PLP
    PHP
    BEQ _fis_dbg_0
.fis_dbg_1
    LDA #121 \ y
    BNE _fis_dbg_any
._fis_dbg_0
    LDA #110 \ n
._fis_dbg_any
    JSR oswrch
    PLP
    RTS

.elim_set
    LDA #0
    STA var_pos
._els_pos
    LDY var_pos
    JSR get_set_cell    \  See if cell is in set
    BEQ _els_not_in     \  Skip if not in set
    
    LDX var_pos
    JSR test_solved
    BEQ _els_not_solved
.els_solved
    \LDA digit
    LDX var_pos
    LDA cands_89v, X
    JSR elim_out        \  Eliminate candidates it sees
    JMP _els_not_in
._els_not_solved
    JSR elim_in         \  Eliminate anything seen as candidate
    LDX var_pos
._els_not_in
    INC var_pos
    LDA solved          \  Terminate loop early if puzzle is finished
    CMP #81
    BCS _els_done
    LDX var_pos
    CPX #81
    BCC _els_pos
._els_done
    RTS
    
    
\  INITIALISE THE ALTERNATE SET TO ALL ZEROS

.init_alt_zero
    LDY #10
    LDA #0
._ia0_0
    STA (alt_ptr), Y
    DEY
    BPL _ia0_0
    RTS

\  INITIALISE THE ALTERNATE SET TO ALL ONES

.init_alt_one
    LDY #10
    LDA #&80            \  Take care of the odd bit
    STA (alt_ptr), Y
    DEY
    LDA #&FF            \  Now we can do the rest all the same
._ia1_0
    STA (alt_ptr), Y
    DEY
    BPL _ia1_0
    RTS

\  INITIALISE THE ALTERNATE SET TO INCLUDE ALL CELLS NOT IN THE
\  MAIN SET
    
.init_alt_for_all
    JSR init_alt_one
    
\  TAKE THE INTERSECTION OF THE ALTERNATE SET WITH THE COMPLEMENT
\  OF THE MAIN SET

.excl_set_alt
    LDA var_pos
    PHA
    LDY #0
    STY var_pos
._esa_test
    JSR get_set_cell    \  Y already contains variable position
    BEQ _esa_not_in     \  Skip if not in main set
    LDY var_pos
    JSR clr_alt_cell    \  Exclude this position from alt set
._esa_not_in
    INC var_pos
    LDY var_pos
    CPY #81
    BCC _esa_test
    PLA
    STA var_pos
    RTS
    
\  TEST TO SEE IF ANY CELLS ARE STILL INCLUDED IN THE ALTERNATE SET
\  ON RETURN Z=1 => NO CELLS
\            Z=0 => ONE OR MORE CELLS

.test_alt
    LDY #10
    LDA (alt_ptr), Y
    AND #&80            \  Ignore bits 81-87
    DEY                 \  Everything else is included
.tea_0
    ORA (alt_ptr), Y    \  Any ones will stick in A
    DEY
    BPL tea_0
\    PHP
\    TAY                 \  We care whether or not Y=0
\    BEQ _tea_empty
\    JSR say
\    EQUS "Not "
\    BRK
\._tea_empty
\    JSR say
\    EQUS "empty."
\    BRK
\    JSR osnewl
\    PLP
    TAY                 \  Make sure A is last thing seen
    RTS

\  REMOVE ALL CELLS FROM THE ALTERNATE SET THAT CANNOT CONTAIN A
\  PARTICULAR DIGIT, GIVEN IN ACCUMULATOR

.and_alt_digit
    TAY                 \  Save the digit
    LDA digit
    PHA
    STY digit
    LDA var_pos
    PHA
    LDY #0
    STY var_pos
._aad_test
    JSR get_alt_cell    \  See if cell is in alt set
    BEQ _aad_not_in
    LDX var_pos
    LDA digit
    JSR test_candidate  \  See if is a candidate
    BNE _aad_not_in     \  Skip if cell *is* a candidate
    LDY var_pos
    JSR clr_alt_cell    \  Remove cell from alt set
._aad_not_in
    INC var_pos
    LDY var_pos
    CPY #81
    BCC _aad_test
._aad_done
    PLA
    STA var_pos
    PLA
    STA digit
    RTS

\  INITIALISE THE ALTERNATE SET WITH ALL CELLS OUTSIDE THE MAIN SET, THAT
\  CAN CONTAIN A DIGIT GIVEN IN THE ACCUMULATOR
    
.init_alt_digit
    TAY                 \  Save the digit
    \LDA digit
    \PHA
    STY digit
    LDA var_pos
    PHA
    LDY #0
    STY var_pos
._iad_test
\    LDX var_pos
\    JSR disp_pos
    LDY var_pos         \  needs to be in Y for this
    JSR get_set_cell
    BNE _iad_clear      \  Clear cell if it is in main set
    LDX var_pos
    LDA digit
    JSR test_candidate  \  See if is a candidate
    BEQ _iad_clear
._iad_set               \  Set cell in alternate set
    LDY var_pos
    JSR set_alt_cell
\    LDA #121            \  "y"
\    JSR oswrch
    JMP _iad_next
._iad_clear             \  Clear cell in alternate set
    LDY var_pos
    JSR clr_alt_cell
\    LDA #110            \  "n"
\    JSR oswrch
._iad_next
    INC var_pos
    LDY var_pos
    CPY #81
    BCC _iad_test
._iad_done
    \JSR osnewl
    PLA
    STA var_pos
    \PLA
    \STA digit
    RTS

\  ORIGINAL BASIC
\
\ 4670DEFPROCelim_ext(D%)
\ 4680LOCALA%,X%,Y%,I%,J%
\ 4690PROCinit_alt_d(D%):PROCshow_alt(66)
\ 4700FORI%=0TO80
\ 4710IFFNcell(I%)=0GOTO4730
\ 4720IFFNtest_cand(I%,D%)PROCand_seen(I%):PROCshow_alt(66):IFFNtest_alt=0I%=80
\ 4730NEXT
\ 4740IFFNtest_alt=0GOTO4780
\ 4750FORI%=0TO80
\ 4760IFFNalt(I%)PROCelim_cand(I%,D%)
\ 4770NEXT
\ 4780ENDPROC

\ 4670DEFPROCelim_ext(D%)
\ 4680LOCALA%,X%,Y%,I%,J%
\ 4690PROCinit_alt_d(D%):PROCshow_alt(66)

.elim_ext
    STA digit           \  The digit we are eliminating
    JSR init_alt_digit
    \LDY #66
    JSR show_alt_66

\ 4700FORI%=0TO80

    LDY #0
    STY var_pos

\ 4710IFFNcell(I%)=0GOTO4730

._elx_test
    JSR get_set_cell
    BEQ _elx_not_in

\ 4720IFFNtest_cand(I%,D%)PROCand_seen(I%):PROCshow_alt(66):IFFNtest_alt=0I%=80

    LDX var_pos
\    JSR disp_pos
    LDA digit
    JSR test_candidate
\    PHP
\    BEQ _elx_n
\    LDA #121            \  "y"
\    JSR oswrch
\    JMP _elx_a
\._elx_n
\    LDA #110            \  "n"
\    JSR oswrch
\._elx_a
\    PLP
    BEQ _elx_not_in     \  Ignore non-candidates
    LDX var_pos
    JSR and_alt_seen    \  Strike out cells it does not see
    \LDY #66
    JSR show_alt_66
    JSR test_alt        \  See if any candidates remain ...
    BEQ _elx_done       \  ... Skip if not

\ 4730NEXT

._elx_not_in
    INC var_pos
\    LDX var_pos
\    JSR disp_pos
\    LDA #58             \  colon
\    JSR oswrch
\    LDA var_pos
\    JSR disp_hex_byte
    LDY var_pos
    CPY #81
    BCC _elx_test

\ 4740IFFNtest_alt=0GOTO4780
\  We have already tested this ...

    \JSR say
    \EQUS "Search done"
    \BRK
    \JSR osnewl

\    JSR test_alt        \  See if any candidates remain ...
\    BEQ _elx_done       \  ... Skip if not

\ 4750FORI%=0TO80

    \LDA digit
    \JSR disp_digit
    \JSR say
    \EQUS " anywhere in "
    \BRK
    \JSR disp_group
    \JSR say
    \EQUS " sees:"
    \BRK
    \JSR osnewl
    
    LDY #0
    STY var_pos
    
\ 4760IFFNalt(I%)PROCelim_cand(I%,D%)

._elx_elim
    JSR get_alt_cell
    BEQ _elx_no_elim

    LDA digit
    JSR disp_digit
    JSR say
    EQUS " anywhere in "
    BRK
    JSR disp_group
    JSR say
    EQUS " sees "
    BRK
    LDX var_pos
    JSR disp_pos
    LDA #46
    JSR oswrch
    JSR osnewl

    LDX var_pos
    LDA digit
    JSR eliminate_candidate

\ 4770NEXT

._elx_no_elim
    INC var_pos
    LDY var_pos
    CPY #81
    BCC _elx_elim
    
\ 4780ENDPROC

._elx_done
    RTS

\  DISPLAY GROUP NAME

.disp_group
    LDY #11
    LDA (set_ptr), Y
    JSR oswrch
    INY
    LDA (set_ptr), Y
    JMP oswrch
    
\  ELIMINATE INWARDS OR OUTWARDS FROM ALL CELLS IN THE GRID

.eliminate_all
    LDX #0
    STX var_pos
._elf_pos
    JSR test_solved
    BEQ _ela_not_solved
.ela_solved
    LDX var_pos
    LDA cands_89v, X
    JSR elim_out        \  Eliminate candidates it sees
    JMP _ela_any
._ela_not_solved
    JSR elim_in         \  Eliminate anything seen as candidate
    LDX var_pos
._ela_any
    INC var_pos
    LDA solved          \  Terminate loop early if puzzle is finished
    CMP #81
    BCS _elf_done
    LDX var_pos
    CPX #81
    BCC _elf_pos
._elf_done
    RTS

\  INITIALISE THE MAIN SET WITH ALL CELLS THAT CAN CONTAIN A DIGIT
\  GIVEN IN THE ACCUMULATOR
    
.init_set_candidate
    STA digit
    ASL A               \  Double it
    TAX
    DEX                 \  Allow for offset
    DEX
    LDA cand_sets, X
    STA set_ptr
    LDA cand_sets+1, X
    STA set_ptr+1
    LDA var_pos
    PHA
    LDX #0
    STX var_pos
._isc_test
    LDA digit
    AND #&7F            \  Ignore column flag
    JSR test_candidate  \  See if is a candidate
    BEQ _isc_clear
._isc_set               \  Set cell in main set
    LDY var_pos
    JSR set_set_cell
    JMP _isc_next
._isc_clear             \  Clear cell in main set
    LDY var_pos
    JSR clr_set_cell
._isc_next
    INC var_pos
    LDX var_pos
    CPX #81
    BCC _isc_test
._isc_done
    PLA
    STA var_pos
    RTS

\  TALLY CELLS IN THE MAIN SET, BY ROW
\  cand_count ET SEQ HOLD THE NUMBER OF CELLS IN EACH ROW THAT CAN
\  CONTAIN THE DIGIT UNDER CONSIDERATION.
\  position_07 ET SEQ AND position_8 ET SEQ HOLD A BITWISE REPRESENTATION
\  OF THE CELLS IN EACH ROW THAT CAN CONTAIN THE DIGIT.
\
\  position_07                         position_8
\  128  64  32  16   8   4   2   1     128 64  32  16   8   4   2   1
\    |   |   |   |   |   |   |   |       |  `-----------------------'
\   C1  C2  C3  C4  C5  C6  C7  C8      C9          not used

.tally_rows
    JSR reset_tally     \  This will leave 0 in A
    STA var_pos
    STA pixelY          \  This will count the rows
    LDX #8              \  Clear the individual row counts
._tyr_clr_0
    STA position_07, X
    STA position_8, X
    DEX
    BPL _tyr_clr_0
._tyr_row
    LDA #0
    STA pixelX          \  This will count the columns
._tyr_col
    LDY var_pos
    JSR get_set_cell
    BEQ _tyr_not_in
._tyr_in
    LDX pixelY          \  Current row
    INC cand_count, X
    LDY pixelX
    CPX #8
    BCS _tyr_in_8
._tyr_in_07             \  Set a bit in columns 1-8 of the row
    LDA position_07, X
    ORA bits_HL, Y
    STA position_07, X
    BNE _tyr_not_in     \  Will always branch
._tyr_in_8              \  Set a bit in column 9 of the row
    LDA position_8, X
    ORA bits_HL-8, Y
    STA position_8, X
._tyr_not_in
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #9
    BCC _tyr_col        \  Loop till end of row
    LDA var_pos
    CMP #81             \  Exit if we have reached end of grid
    BCS _tyr_done
    INC pixelY
    BNE _tyr_row        \  Not expected to fall through
._tyr_done
    LDA digit
    AND #&7F            \  Clear "column" flag
    STA digit
    RTS
    
\  TALLY CELLS IN THE MAIN SET, BY COLUMN
\  AS ABOVE EXCEPT
\  position_07                         position_8
\  128  64  32  16   8   4   2   1     128 64  32  16   8   4   2   1
\    |   |   |   |   |   |   |   |       |  `-----------------------'
\   R1  R2  R3  R4  R5  R6  R7  R8      C9          not used

.tally_columns
    JSR reset_tally     \  This will leave 0 in A
    STA var_pos
    STA pixelY          \  This will count the rows
    LDX #8              \  Clear the individual row counts
._tyc_clr_0
    STA position_07, X
    STA position_8, X
    DEX
    BPL _tyc_clr_0
._tyc_row
    LDA #0
    STA pixelX          \  This will count the columns
._tyc_col
    LDY var_pos
    JSR get_set_cell
    BEQ _tyc_not_in
._tyc_in
    LDX pixelX          \  Current column
    INC cand_count, X
    LDY pixelY
    CPY #8
    BCS _tyc_in_8
._tyc_in_07             \  Set a bit in rows 1-8 of the column
    LDA position_07, X
    ORA bits_HL, Y
    STA position_07, X
    BNE _tyc_not_in     \  Will always branch
._tyc_in_8              \  Set a bit in row 9 of the column
    LDA position_8, X
    ORA bits_HL-8, Y
    STA position_8, X
._tyc_not_in
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #9
    BCC _tyc_col        \  Loop till end of row
    LDA var_pos
    CMP #81             \  Exit if we have reached end of grid
    BCS _tyc_done
    INC pixelY
    BNE _tyc_row        \  Not expected to fall through
._tyc_done
    LDA digit
    ORA #&80            \  Set "column" flag
    STA digit
    RTS
    
\  FISH FOR A SWORDFISH!
\
\  EXPECTS cand_count ET SEQ TO BE FILLED WITH NUMBERS OF POSSIBLE
\  HOMES FOR THE DIGIT IN EACH ROW/COLUMN, AND BIT 7 OF digit TO BE
\  CLEAR IF WORKING BY ROW, OR SET IF WORKING BY COLUMN.

.fish_for_swordfish
    LDA #0
    STA pos1            \  Start with 1st R/C at 0
._fsf_pos1_top
    LDX pos1
    LDA cand_count, X
    CMP #2
    BCC _fsf_pos1_btm   \  Skip if fewer than 2 homes
    CMP #4
    BCS _fsf_pos1_btm   \  Skip if more than 3 homes

    LDX pos1            \  Start with 2nd R/C just after 1st
    INX
    STX pos2
    
._fsf_pos2_top
    LDX pos2
    LDA cand_count, X
    CMP #2
    BCC _fsf_pos2_btm   \  Skip if fewer than 2 homes
    CMP #4
    BCS _fsf_pos2_btm   \  Skip if more than 3 homes

    LDX pos2            \  Start with 3rd R/C just after 2nd
    INX
    STX pos3
    
._fsf_pos3_top
    LDX pos3
    LDA cand_count, X
    CMP #2
    BCC _fsf_pos3_btm   \  Skip if fewer than 2 homes
    CMP #4
    BCS _fsf_pos3_btm   \  Skip if more than 3 homes

    JSR _fsf_pos3_ok
    
._fsf_pos3_btm
    LDA solved          \  Terminate loop early if puzzle is finished
    CMP #81
    BEQ _fsf_done
    INC pos3
    LDA pos3
    CMP #9              \  Last of three
    BCC _fsf_pos3_top
    
._fsf_pos2_btm
    INC pos2
    LDA pos2
    CMP #8              \  Second of three
    BCC _fsf_pos2_top
    
._fsf_pos1_btm
    INC pos1
    LDA pos1
    CMP #7              \  First of three
    BCC _fsf_pos1_top
._fsf_done
    RTS
    
._fsf_pos3_ok

    \  COUNT THE CANDIDATES IN CASE IT IS NOT A REAL SWORDFISH

    LDX pos1            \  Make a copy of the swordfish positions
    LDA position_07, X
    LDX pos2
    ORA position_07, X
    LDX pos3
    ORA position_07, X
    STA cand_copy
    STA product         \  Sacrificial copy to count bits
    LDA position_8, X
    LDX pos2
    ORA position_8, X
    LDX pos1
    ORA position_8, X
    STA cand_copy+1
    STA product+1
    
    \  If there are more than 3 bits set in the copy, the rows and
    \  columns do not line up, meaning it is not a real swordfish.
    
._fsf_count_pos
    LDA #0
    STA product+2
    TAX
._fsf_cp_3
    ASL product+1
    ROL product
    BCC _fsf_cp_4
    INC product+2
._fsf_cp_4
    INX
    CPX #9
    BCC _fsf_cp_3
    LDA product+2        
    CMP #3
    BEQ _esf_real_swordfish
    RTS
    
._esf_real_swordfish    
    JSR eliminate_swordfish
    JSR test_alt
    BEQ _fsf_no_elim
    
    JSR say
    EQUS "Swordfish "
    BRK
    LDA digit
    AND #&7F            \  Ignore column flag
    JSR disp_digit_sp
    \JSR say
    \EQUS " in "
    \BRK
    BIT digit
    BMI _fsf_hit_C
    LDA #82             \  "R"
    BNE _fsf_hit_any
._fsf_hit_C
    LDA #67             \  "C"
._fsf_hit_any
    JSR oswrch
    LDA pos1
    JSR disp_digit_inc
    LDA pos2
    JSR disp_digit_inc
    LDA pos3
    JSR disp_digit_inc
    BIT digit
    BMI _fsf_hit_C2
    LDA #67             \  "C"
    BNE _fsf_hit_any2
._fsf_hit_C2
    LDA #82             \  "R"
._fsf_hit_any2
    JSR oswrch
    LDA cand_copy
    STA product
    LDA cand_copy+1
    STA product+1
    LDX #0
._fsf_disp_col
    ASL product+1
    ROL product
    BCC _fsf_dc1
    TXA
    JSR disp_digit_inc
._fsf_dc1
    INX
    CPX #9
    BCC _fsf_disp_col
    LDA #58             \  colon
    JSR oswrch
    JSR osnewl
    JSR elim_alt
    
    \  NOW WE HAVE TO RE-TALLY THE ROWS OR COLUMNS
    \  BECAUSE SOME DIGITS MAY HAVE BEEN ELIMINATED
    
._fsf_retally
    LDY #57             \  Re-display the main set
    JSR show_set
    BIT digit
    BMI _fsf_retally_cols
._fsf_retally_rows
    JMP tally_rows
._fsf_retally_cols
    JMP tally_columns    
._fsf_no_elim
    RTS
    
.eliminate_swordfish
    JSR init_alt_zero   \  Start with alt set empty
    STA var_pos         \  A will be 0 here
    STA pixelX
    STA pixelY
    BIT digit
    BPL elim_sf_rows
    JMP elim_sf_cols
.elim_sf_rows
    LDY pixelY
._esr_row
    CPY pos1
    BEQ _esr_not_this   \  Skip rows in the swordfish
    CPY pos2
    BEQ _esr_not_this
    CPY pos3
    BEQ _esr_not_this
    LDX #0              \  Work along row, eliminating candidates from
    STX pixelX          \  columns which are part of the swordfish.
._esr_col
    CPX #8
    BCS _esr_col_8
._esr_col_07            \  Test if column 0-7 is in swordfish
    LDA cand_copy
    AND bits_HL, X
    BEQ _esr_not_in
    BNE _esr_in
._esr_col_8
    LDA cand_copy+1
    AND bits_HL-8, X
    BEQ _esr_not_in
._esr_in
    JSR sf_maybe_elim
._esr_not_in
    INC pixelX
    LDX pixelX
    CPX #9
    BCC _esr_col
._esr_not_this
    INC pixelY
    LDY pixelY
    CPY #9
    BCC _esr_row
    \LDY #66             \  Display contents of alternate set at row 66
    JMP show_alt_66
    RTS

.elim_sf_cols
    LDX pixelX
._esc_col
    CPX pos1
    BEQ _esc_not_this   \  Skip column in the swordfish
    CPX pos2
    BEQ _esc_not_this
    CPX pos3
    BEQ _esc_not_this
    LDY #0              \  Work down column, eliminating candidates from
    STY pixelY          \  rows which are part of the swordfish.
._esc_row
    CPY #8
    BCS _esc_row_8
._esc_row_07            \  Test if column 0-7 is in swordfish
    LDA cand_copy
    AND bits_HL, X
    BEQ _esc_not_in
    BNE _esc_in
._esc_row_8
    LDA cand_copy+1
    AND bits_HL-8, Y
    BEQ _esc_not_in
._esc_in
    JSR sf_maybe_elim
._esc_not_in
    INC pixelY
    LDX pixelY
    CPX #9
    BCC _esc_row
._esc_not_this
    INC pixelY
    LDY pixelY
    CPY #9
    BCC _esc_col
    \LDY #66             \  Display contents of alternate set at row 66
    JMP show_alt_66
    RTS

\  SET A CELL IN ROW Y, COLUMN X OF THE ALTERNATE SET IF THE
\  CORRESPONDING POSITION IN THE MAIN SET IS SET

.sf_maybe_elim
    LDA pixelY
    ASL A
    ASL A
    ASL A               \  Now we have Y * 8; Carry should be clear
    ADC pixelY          \  Now we have Y * 9
    ADC pixelX          \  Now we have Y * 9 + X
    TAY
    PHA
    JSR get_set_cell
    BEQ _sfe_not_cand
    PLA
    TAY
    JMP set_alt_cell
._sfe_not_cand
    PLA
    RTS

\  X-WINGS AND SKYSCRAPERS
\
\  AN X-WING IS REALLY JUST A SPECIAL KIND OF SKYSCRAPER
\
\  pos1 AND pos2 ARE THE ONLY TWO CANDIDATE CELLS FOR OUR DIGIT IN THE
\  SAME ROW (column)
\  pos3 AND pos4 ARE THE ONLY TWO CANDIDATE CELLS FOR OUR DIGIT IN A
\  DIFFERENT ROW (column)
\  NOW IF pos1 SEES pos3 THEN WE CAN ELIMINATE OUR DIGIT AS A CANDIDATE
\  FROM ANY CELL SEE BY pos2 AND pos4; IF pos2 SEES pos4 THEN WE CAN
\  ELIMINATE OUR DIGIT AS A CANDIDATE FROM ANY CELL SEE BY pos2 AND pos4.
\  

\  SEARCH FOR A SKYSCRAPER / X-WING IN ROWS

.search_ss_xw_rows
    LDY #0
    STY pixelY          \  This will count the rows
._sxr_ab_top
    LDA cand_count, Y   \  Get number of candidate cells in row Y
    CMP #2              \  See if there are exactly two
    BNE _sxr_ab_btm
    
    \  NOW WE HAVE OUR A-B ROW IN pixelY
    
    LDA pixelY          \  Save this while we find a C-D row
    PHA
    
    LDX #0
    STX pixelX
._sxr_a_0
    JSR conv_pixel      \  Get position
    TAY
    JSR get_set_cell    \  See if it's in the set
    BNE _sxr_a_1        \  Jump out if it's in
    INC pixelX
    LDX pixelX
    CPX #8
    BCC _sxr_a_0
    RTS                 \  Not ideal
._sxr_a_1
    JSR conv_pixel
    STA pos1            \  pos1 holds A position
    
    INC pixelX
    LDX pixelX

._sxr_b_0
    JSR conv_pixel      \  Get position
    TAY
    JSR get_set_cell    \  See if it's in the set
    BNE _sxr_b_1        \  Jump out if it's in
    INC pixelX
    LDX pixelX
    CPX #8
    BCC _sxr_b_0
    BCS _sxr_cd_btm     \  Should never happen
._sxr_b_1
    JSR conv_pixel
    STA pos2            \  pos2 holds B position

    INC pixelY          \  Begin C-D search on next row
    LDY pixelY
._sxr_cd_top
    LDA cand_count, Y   \  Get number of candidate cells in row Y
    CMP #2              \  See if there are exactly two
    BNE _sxr_cd_btm
    
    \  NOW WE HAVE OUR C-D ROW IN pixelY

    LDX #0
    STX pixelX
    JSR search_row
    STA pos3
    INC pixelX
    LDX pixelX
    JSR search_row
    STA pos4
    
    PLA                 \  We pushed A-B row earlier
    RTS
    
._sxr_cd_btm
    INC pixelY          \  Next row
    LDY pixelY
    CPY #9
    BCC _sxr_cd_top
    
    PLA
    STA pixelY          \  Restore original A-B row
._sxr_ab_btm
    INC pixelY          \  Next row
    LDY pixelY
    CPY #8
    BCC _sxr_ab_top
    
    SEC                 \  C=1 => nothing found
    RTS

\  SEARCH FOR A SKYSCRAPER / X-WING IN COLUMNS

.search_ss_xw_columns
    LDX #0
    STX pixelX          \  This will count the columns
._sxc_ab_top
    LDA cand_count, X   \  Get number of candidate cells in col X
    CMP #2              \  See if there are exactly two
    BNE _sxc_ab_btm
    
    \  NOW WE HAVE OUR A-B COLUMN IN pixelX
    
    LDA pixelX          \  Save this while we find a C-D column
    PHA
    
    LDY #0
    STY pixelY
    JSR search_col
    STA pos1
    INC pixelY
    LDY pixelY
    JSR search_col
    BCS _sxc_cd_btm     \  Should never happen
    STA pos2            \  pos2 holds B position

    INC pixelX          \  Begin C-D search on next row
    LDX pixelX
._sxc_cd_top
    LDA cand_count, X   \  Get number of candidate cells in row Y
    CMP #2              \  See if there are exactly two
    BNE _sxc_cd_btm
    
    \  NOW WE HAVE OUR C-D COLUMN IN pixelX

    LDX #0
    STX pixelY
    JSR search_col
    STA pos3
    INC pixelY
    LDX pixelY
    JSR search_col
    STA pos4
    
    PLA                 \  We pushed A-B row earlier
    RTS
    
._sxc_cd_btm
    INC pixelX          \  Next row
    LDX pixelX
    CPX #9
    BCC _sxc_cd_top
    
    PLA
    STA pixelX          \  Restore original A-B column
._sxc_ab_btm
    INC pixelX          \  Next column
    LDX pixelX
    CPX #8
    BCC _sxc_ab_top
    
    SEC                 \  C=1 => nothing found
    RTS

\  CONVERT PIXEL CO-ORDINATES pixelX, pixelY TO POSITION

.conv_pixel
    LDA pixelY
    ASL A
    ASL A
    ASL A               \  Now we have Y * 8; Carry should be clear
    ADC pixelY          \  Now we have Y * 9
    ADC pixelX          \  Now we have Y * 9 + X
    RTS

\  SEARCH A ROW HORIZONTALLY FOR A CELL IN THE MAIN SET

.search_row
    JSR conv_pixel      \  Get position
    TAY
    JSR get_set_cell    \  See if it's in the set
    BNE _sr_1           \  Jump out if it's in
.search_row_1
    INC pixelX
    LDX pixelX
    CPX #9
    BCC search_row
    RTS                 \  With C=1
._sr_1
    JSR conv_pixel      \  Return position in A
    CLC                 \  With C=0 => success
    RTS

\  SEARCH A COLUMN FOR A CELL IN THE MAIN SET

.search_col
    JSR conv_pixel      \  Get position
    TAY
    JSR get_set_cell    \  See if it's in the set
    BNE _sr_1           \  Jump out if it's in
.search_col_1
    INC pixelY
    LDY pixelY
    CPY #9
    BCC search_col
    RTS                 \  With C=1
    
\  TEST A PUTATIVE SKYSCRAPER/X-WING FOR ELIMINATIONS
\  EXPECTS pos1 AND pos2 TO BE IN SAME ROW/COLUMN
\  pos3 AND pos4 TO BE IN OTHER ROW/COLUMN

.test_ss_xw
    JSR reset_alt       \  Start with alternate set empty
    JSR init_alt_zero
    LDX #alt_set_1 MOD 256
    LDY #alt_set_1 DIV 256
    JSR seed_alt_ptr    \  Set up a safe alternate set to work with
    LDX pos1
    LDY pos3
    JSR get_see
    BEQ _tsx_a_miss_c
    LDX pos2
    LDY pos4
    JSR elim_seen_both
._tsx_a_miss_c
    LDX pos2
    LDY pos4
    JSR get_see
    BEQ _tsx_b_miss_d
    LDX pos1
    LDY pos3
    JSR elim_seen_both
._tsx_b_miss_d
    LDX pos2
    LDY pos3
    JSR get_see
    BEQ _tsx_b_miss_c
    LDX pos1
    LDY pos4
    JSR elim_seen_both
._tsx_b_miss_c
    LDX pos1
    LDY pos4
    JSR get_see
    BEQ _tsx_a_miss_d
    LDX pos2
    LDY pos3
    JSR elim_seen_both
._tsx_a_miss_d
    JSR reset_alt       \  Retrieve the eliminations
    JSR test_alt
    BEQ _tsx_no_elim
    JSR say
    EQUS "Skyscraper or X-wing on ";
    BRK
    LDA digit
    AND #&0F
    JSR disp_digit_sp
    JSR say
    EQUS "in "
    BRK
    LDX pos1
    JSR disp_pos
    LDA #44             \  comma
    JSR oswrch
    LDX pos2
    JSR disp_pos
    LDA #47             \  slash
    JSR oswrch
    LDX pos3
    JSR disp_pos
    LDA #44             \  comma
    JSR oswrch
    LDX pos4
    JSR disp_pos
    LDA #58             \  colon
    JSR oswrch
    JMP osnewl
._tsx_no_elim
    RTS
    
\  FIND CELLS IN MAIN SET WHICH ARE SEEN FROM TWO POSITIONS GIVEN IN X AND Y
\  ON RETURN THE COMMON CELLS WILL BE IN THE ALTERNATE SET
    
.elim_seen_both
    TXA                 \  Save X for later
    PHA
    TYA                 \  Save Y for later
    PHA
    JSR init_alt_main   \  Initialise alt set with clone of main set
    \JSR show_alt_66
    PLA                 \  Retrieve Y saved earlier
    TAX
    JSR int_alt_seen    \  Remove anything it does not see
    JSR show_alt_66
    PLA                 \  Retrieve X saved earlier
    TAX
    JSR int_alt_seen    \  Remove anything it does not see
    JSR show_alt_66
    JSR test_alt
    BEQ _esb_none       \  Skip if nothing to eliminate
    JMP union_alt       \  Save cells to be eliminated
._esb_none
    RTS
    
\  ELIMINATE CANDIDATES FROM POSITIONS IN THE ALTERNATE SET

.elim_alt
    LDA var_pos         \  Store var_pos on the stack
    PHA
    LDY #0
    STY var_pos
._ela_pos
    JSR get_alt_cell
    BEQ _ela_not_in
    LDY var_pos         \  Eliminate from the main set also
    JSR clr_set_cell
    LDX var_pos
    LDA digit
    AND #&7F            \  Ignore column flag
    JSR eliminate_candidate
    LDX var_pos
    JSR disp_contents
._ela_not_in
    LDA solved          \  Terminate loop early if puzzle is finished
    CMP #81
    BEQ _ela_done
    INC var_pos
    LDY var_pos
    CPY #81
    BCC _ela_pos
._ela_done
    PLA
    STA var_pos         \  Retrieve var_pos
    RTS

.reset_alt
    LDX #alt_set_map MOD256
    LDY #alt_set_map DIV256
.seed_alt_ptr
    STX alt_ptr
    STY alt_ptr+1
    RTS

\  TAKE THE UNION OF THE "REAL" ALTERNATE SET WITH THE CURRENT ALTERNATE
\  SET

.union_alt
    LDY #10
._una_0
    LDA alt_set_map, Y
    ORA (alt_ptr), Y
    STA alt_set_map, Y
    DEY
    BPL _una_0
    LDA alt_set_map+10  \  Only use bit 7 of byte 10
    AND #&80
    STA alt_set_map+10
    RTS
    
\  TAKE THE INTERSECTION OF THE ALTERNATE SET WITH WHATEVER IS SEEN FROM
\  A POSITION GIVEN IN X

.int_alt_seen
    LDA fix_pos
    PHA
    LDA var_pos
    PHA
    STX fix_pos         \  The position we care what sees    
    LDA #0
    STA var_pos
    TAX
._ias_0
    LDY fix_pos
    JSR get_see
    BNE _ias_1          \  Don't clear cell if it is seen
._ias_clr
    LDY var_pos
    JSR clr_alt_cell    \  Clear cell if it was not seen
._ias_1
    INC var_pos
    LDX var_pos
    CPX #81             \  See if we have reached end
    BCC _ias_0
._ias_done
    LDX fix_pos         \  We can restore this
    PLA
    STA var_pos
    PLA
    STA fix_pos
    RTS

\  INITIALISE THE ALT SET WITH A COPY OF THE MAIN SET

.init_alt_main
    LDY #0
._cam_0
    LDA (set_ptr), Y
    STA (alt_ptr), Y
    INY
    CPY #10
    BCC _cam_0
    DEY
    AND #&80
    STA (alt_ptr), Y
    RTS
    
\  DISPLAY A MULTI-DIGIT DECIMAL NUMBER
\
\  Fast division only works for odd divisors!  
.disp_dec
    LSR A               \  Now we have A DIV 2 and C=A MOD 2
    PHP                 \  Save the carry flag
    LDX #&A0
    STX divisor
    JSR fast_divide     \  Now we have A DIV 10
    STY units           \  This is (A DIV 2) MOD 5
    PLP                 \  Retrieve C from before
    ROL units           \  Now we have 2 * ((A DIV 2) MOD 5) + A MOD 2 ...
                        \  ... which is equivalent to A MOD 10
    STA tens
    BEQ _dd_no_10s      \  Skip straight to units if no tens
    CMP #10
    BCC _dd_no_100s     \  Skip straight to tens if no hundreds
    LDX #0
    STX hundreds
._dd_hund
    SEC
    SBC #10
    STA tens
    INC hundreds
    CMP #10
    BCS _dd_hund
    LDA hundreds
    JSR disp_digit
._dd_no_100s
    LDA tens
    JSR disp_digit
._dd_no_10s
    LDA units
    
\  DISPLAY A SINGLE DIGIT

.disp_digit
    PHA
    ORA #&30
    JSR oswrch
    PLA
    RTS

\  DISPLAY A DIGIT INCREASED BY 1
\  THIS IS USEFUL FOR DISPLAYING HUMAN-FRIENDLY VERSIONS OF INTERNAL
\  ROW/COLUMN NUMBERS WHICH NATURALLY GO FROM 0 TO 8
    
.disp_digit_inc
    PHA
    SEC
    ADC #&30
    JSR oswrch
    PLA
    RTS
    
\  DISPLAY A SINGLE DIGIT FOLLOWED BY A SPACE

.disp_digit_sp
    PHA
    ORA #&30
    JSR oswrch
    LDA #32
    JSR oswrch
    PLA
    RTS


.say
    PHP                 \  Stash everything on the 6502 stack
    PHA
    TYA
    PHA
    TXA
    PHA                 \  Now there are 4 bytes on top of return addr-1
    TSX                 \  &101 + stack pointer => most recently pushed
    LDA &105, X
    STA text_ptr        \  Low byte of return address-1
    LDA &106, X
    STA text_ptr+1      \  High byte of return address-1
    LDY #1              \  Start one ahead of address on stack
._ss_say_1
    LDA (text_ptr), Y
    BEQ _ss_say_2       \  Don't send CHR$(0)
    INY
    JSR osasci
    CMP #&20            \  Stop printing after any control char
    BCS _ss_say_1
    DEY                 \  We no longer need to compensate for address-1
._ss_say_2
    TYA                 \  Overwrite old return address with new value
    CLC                 \  adjusted by length of string we just printed
    ADC text_ptr
    TSX
    STA &105, X
    LDA text_ptr+1
    ADC #0
    STA &106, X
    PLA                 \  Retrieve the values we stashed earlier
    TAX
    PLA
    TAY
    PLA
    PLP
    RTS                 \  To the modified address

    
.dump_grid
    LDA #42
    JSR oswrch
.dump_grid1
    LDX #0
._dpg_0
    LDA cands_17, X
    JSR disp_hex_byte
    LDA cands_89v, X
    JSR disp_hex_byte
    INX
    CPX #81
    BCC _dpg_0
    JMP osnewl
    
.disp_hex_cands
    PHA
    TYA
    PHA
    TXA
    PHA
    LDA #43             \  "+"
    JSR oswrch
    TXA
    JSR disp_hex_byte
    LDA cands_17, X
    JSR disp_hex_byte
    LDA cands_89v, X
    JSR disp_hex_byte
    PLA
    TAX
    PLA
    TAY
    PLA
    RTS
    
.disp_hex_byte
    PHA
    JSR lsra4
    JSR disp_hex_nybble
    PLA
    AND #&F
.disp_hex_nybble
    ORA #&30
    CMP #&3A
    BCC _dhn_09
    ADC #6              \  We know C=1 here, because BCS did not branch
._dhn_09
    JMP oswrch
    
    
    
ALIGN &100

\  DIGIT PATTERNS
\
\  EACH DIGIT HAS 4 BYTES WHICH GIVE THE CHARACTER CODES FOR ITS GLYPH
\  IN EACH OF 2 ROWS OF 2 COLUMNS.  A THIRD, EMPTY COLUMN WILL BE ADDED
\  WHEN IT IS WRITTEN TO THE SCREEN.

.digit_patt
    EQUD &20202020
    EQUD &25203528
    EQUD &2C2D7B73
    EQUD &2E2C7B73
    EQUD &2A207A75
    EQUD &2E2C7377
    EQUD &2E2D7377
    EQUD &2A206B27
    EQUD &2E2D7B77
    EQUD &2E2C7B77
    \  digit "10" is underscore for cursor
    EQUD &70702020

\  PENCIL MARK PATTERNS
\
\  EACH DIGIT HAS 6 BYTES WHICH GIVE THE PIXEL VALUES IN EACH OF 2 ROWS
\  OF 3 COLUMNS.

.pmk_patt
    EQUW &0000:EQUD &00000000
    EQUW &0001:EQUD &00000000
    EQUW &0100:EQUD &00000000
    EQUW &0000:EQUD &00000001
    EQUW &0010:EQUD &00000000
    EQUW &1000:EQUD &00000000
    EQUW &0000:EQUD &00000010
    EQUW &0000:EQUD &00000400
    EQUW &0000:EQUD &00040000
    EQUW &0000:EQUD &04000000

\  X, Y CO-ORDINATES FOR GRID POSITIONS
\
\  HIGH NYBBLE = Y CO-ORDINATE
\  LOW NYBBLE  = X CO-ORDINATE

.xy_coords
    EQUD &03020100:EQUD &07060504:EQUB &08
    EQUD &13121110:EQUD &17161514:EQUB &18
    EQUD &23222120:EQUD &27262524:EQUB &28
    EQUD &33323130:EQUD &37363534:EQUB &38
    EQUD &43424140:EQUD &47464544:EQUB &48
    EQUD &53525150:EQUD &57565554:EQUB &58
    EQUD &63626160:EQUD &67666564:EQUB &68
    EQUD &73727170:EQUD &77767574:EQUB &78
    EQUD &83828180:EQUD &87868584:EQUB &88

.boxes
    EQUD &01000000:EQUD &02020101:EQUB &02
    EQUD &01000000:EQUD &02020101:EQUB &02
    EQUD &01000000:EQUD &02020101:EQUB &02
    EQUD &04030303:EQUD &05050404:EQUB &05
    EQUD &04030303:EQUD &05050404:EQUB &05
    EQUD &04030303:EQUD &05050404:EQUB &05
    EQUD &07060606:EQUD &08080707:EQUB &08
    EQUD &07060606:EQUD &08080707:EQUB &08
    EQUD &07060606:EQUD &08080707:EQUB &08

.bits_HL
    EQUD &10204080:EQUD &01020408
    
.map_pos
    EQUB 84:EQUB 83:EQUB 82:EQUB 81:EQUB 80
    EQUB 44:EQUB 43:EQUB 42:EQUB 41:EQUB 40
    EQUB 4:EQUB 3:EQUB 2:EQUB 1:EQUB 0

.cand_sets
    EQUW all_ones
    EQUW all_twos
    EQUW all_threes
    EQUW all_fours
    EQUW all_fives
    EQUW all_sixes
    EQUW all_sevens
    EQUW all_eights
    EQUW all_nines

.slack_space
    
ORG &7500

.alt_set_map
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00

.position_07
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00
.position_8
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00

.alt_set_1
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
.alt_set_2
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00

ALIGN &80

.group_map
    EQUB&FF:EQUB&80:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00 \ R1
    EQUS "R1"
    
    EQUB&00:EQUB&7F:EQUB&C0:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00 \ R2
    EQUS "R2"
    
    EQUB&00:EQUB&00:EQUB&3F:EQUB&E0:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00 \ R3
    EQUS "R3"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&1F:EQUB&F0:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "R4"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&0F:EQUB&F8:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "R5"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&07:EQUB&FC:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "R6"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&03:EQUB&FE
    EQUB&00:EQUB&00:EQUB&00
    EQUS "R7"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&01
    EQUB&FF:EQUB&00:EQUB&00
    EQUS "R8"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&FF:EQUB&80 \ R9
    EQUS "R9"
    
    EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01
    EQUB&00:EQUB&80:EQUB&00 \ C1
    EQUS "C1"
    
    EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00
    EQUB&80:EQUB&40:EQUB&00
    EQUS "C2"
    
    EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80
    EQUB&40:EQUB&20:EQUB&00
    EQUS "C3"
    
    EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40
    EQUB&20:EQUB&10:EQUB&00
    EQUS "C4"
    
    EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20
    EQUB&10:EQUB&08:EQUB&00
    EQUS "C5"
    
    EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10
    EQUB&08:EQUB&04:EQUB&00
    EQUS "C6"
    
    EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08
    EQUB&04:EQUB&02:EQUB&00
    EQUS "C7"
    
    EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04
    EQUB&02:EQUB&01:EQUB&00
    EQUS "C8"
    
    EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02
    EQUB&01:EQUB&00:EQUB&80 \ C9
    EQUS "C9"
    
    EQUB&E0:EQUB&70:EQUB&38:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00 \ B1
    EQUS "B1"
    
    EQUB&1C:EQUB&0E:EQUB&07:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "B2"
    
    EQUB&03:EQUB&81:EQUB&C0:EQUB&E0:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "B3"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&1C:EQUB&0E:EQUB&07:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "B4"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&03:EQUB&81:EQUB&C0:EQUB&E0:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "B5"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&70:EQUB&38:EQUB&1C:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "B6"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&03:EQUB&81
    EQUB&C0:EQUB&E0:EQUB&00
    EQUS "B7"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&70
    EQUB&38:EQUB&1C:EQUB&00
    EQUS "B8"
    
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&0E
    EQUB&07:EQUB&03:EQUB&80 \ B9
    EQUS "B9"

.all_ones
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "1s"
.all_twos
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "2s"
.all_threes
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "3s"
.all_fours
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "4s"
.all_fives
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "5s"
.all_sixes
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "6s"
.all_sevens
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "7s"
.all_eights
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "8s"
.all_nines
    EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00:EQUB&00
    EQUB&00:EQUB&00:EQUB&00
    EQUS "9s"

ORG &7800

.vision_map
    EQUB&7F:EQUB&F0:EQUB&38:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01
    EQUB&00:EQUB&80:EQUB&5F:EQUB&F8:EQUB&1C:EQUB&04:EQUB&02:EQUB&01
    EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&37:EQUB&FC:EQUB&0E:EQUB&01
    EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&1D:EQUB&F1
    EQUB&C0:EQUB&E0:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02
    EQUB&0F:EQUB&78:EQUB&E0:EQUB&70:EQUB&10:EQUB&08:EQUB&04:EQUB&02
    EQUB&01:EQUB&00:EQUB&87:EQUB&DC:EQUB&70:EQUB&38:EQUB&04:EQUB&02
    EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&23:EQUB&F6:EQUB&07:EQUB&03
    EQUB&81:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&09:EQUB&FD
    EQUB&03:EQUB&81:EQUB&C0:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04
    EQUB&02:EQUB&FF:EQUB&01:EQUB&C0:EQUB&E0:EQUB&10:EQUB&08:EQUB&04
    EQUB&02:EQUB&01:EQUB&00:EQUB&F0:EQUB&1F:EQUB&FC:EQUB&08:EQUB&04
    EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&38:EQUB&17:EQUB&FE
    EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&1C
    EQUB&0D:EQUB&FF:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08
    EQUB&04:EQUB&01:EQUB&C7:EQUB&7C:EQUB&70:EQUB&20:EQUB&10:EQUB&08
    EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&E3:EQUB&DE:EQUB&38:EQUB&08
    EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&71:EQUB&F7
    EQUB&1C:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10
    EQUB&07:EQUB&FD:EQUB&81:EQUB&C0:EQUB&80:EQUB&40:EQUB&20:EQUB&10
    EQUB&08:EQUB&04:EQUB&03:EQUB&FF:EQUB&40:EQUB&E0:EQUB&20:EQUB&10
    EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&01:EQUB&FF:EQUB&C0:EQUB&70
    EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&78:EQUB&1C
    EQUB&07:EQUB&FC:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20
    EQUB&1C:EQUB&0E:EQUB&05:EQUB&FD:EQUB&00:EQUB&80:EQUB&40:EQUB&20
    EQUB&10:EQUB&08:EQUB&0E:EQUB&07:EQUB&03:EQUB&7E:EQUB&40:EQUB&20
    EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&00:EQUB&E0:EQUB&71:EQUB&DF
    EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&70
    EQUB&38:EQUB&F7:EQUB&84:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40
    EQUB&20:EQUB&38:EQUB&1C:EQUB&7D:EQUB&C1:EQUB&00:EQUB&80:EQUB&40
    EQUB&20:EQUB&10:EQUB&08:EQUB&03:EQUB&81:EQUB&FF:EQUB&60:EQUB&40
    EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&C0:EQUB&FF
    EQUB&D0:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80
    EQUB&E0:EQUB&7F:EQUB&F0:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80
    EQUB&40:EQUB&30:EQUB&08:EQUB&04:EQUB&01:EQUB&FF:EQUB&C0:EQUB&E0
    EQUB&40:EQUB&20:EQUB&10:EQUB&04:EQUB&02:EQUB&01:EQUB&01:EQUB&7F
    EQUB&E0:EQUB&70:EQUB&10:EQUB&08:EQUB&04:EQUB&01:EQUB&00:EQUB&80
    EQUB&40:EQUB&DF:EQUB&F0:EQUB&38:EQUB&04:EQUB&02:EQUB&01:EQUB&00
    EQUB&40:EQUB&20:EQUB&10:EQUB&77:EQUB&C7:EQUB&03:EQUB&81:EQUB&00
    EQUB&80:EQUB&40:EQUB&10:EQUB&08:EQUB&04:EQUB&3D:EQUB&E3:EQUB&81
    EQUB&C0:EQUB&40:EQUB&20:EQUB&10:EQUB&04:EQUB&02:EQUB&01:EQUB&1F
    EQUB&71:EQUB&C0:EQUB&E0:EQUB&10:EQUB&08:EQUB&04:EQUB&01:EQUB&00
    EQUB&80:EQUB&4F:EQUB&D8:EQUB&1C:EQUB&0E:EQUB&04:EQUB&02:EQUB&01
    EQUB&00:EQUB&40:EQUB&20:EQUB&17:EQUB&F4:EQUB&0E:EQUB&07:EQUB&01
    EQUB&00:EQUB&80:EQUB&40:EQUB&10:EQUB&08:EQUB&07:EQUB&FC:EQUB&07
    EQUB&03:EQUB&80:EQUB&40:EQUB&20:EQUB&18:EQUB&04:EQUB&02:EQUB&01
    EQUB&C0:EQUB&7F:EQUB&F0:EQUB&20:EQUB&10:EQUB&08:EQUB&02:EQUB&01
    EQUB&00:EQUB&80:EQUB&E0:EQUB&5F:EQUB&F8:EQUB&08:EQUB&04:EQUB&02
    EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&70:EQUB&37:EQUB&FC:EQUB&02
    EQUB&01:EQUB&00:EQUB&80:EQUB&20:EQUB&10:EQUB&08:EQUB&07:EQUB&1D
    EQUB&F1:EQUB&C0:EQUB&80:EQUB&40:EQUB&20:EQUB&08:EQUB&04:EQUB&02
    EQUB&03:EQUB&8F:EQUB&78:EQUB&E0:EQUB&20:EQUB&10:EQUB&08:EQUB&02
    EQUB&01:EQUB&00:EQUB&81:EQUB&C7:EQUB&DC:EQUB&70:EQUB&08:EQUB&04
    EQUB&02:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&1F:EQUB&F6:EQUB&07
    EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&20:EQUB&10:EQUB&08:EQUB&0F
    EQUB&FD:EQUB&03:EQUB&80:EQUB&80:EQUB&40:EQUB&20:EQUB&08:EQUB&04
    EQUB&02:EQUB&07:EQUB&FF:EQUB&01:EQUB&C0:EQUB&20:EQUB&10:EQUB&0C
    EQUB&02:EQUB&01:EQUB&00:EQUB&E0:EQUB&70:EQUB&1F:EQUB&F0:EQUB&08
    EQUB&04:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&70:EQUB&38:EQUB&17
    EQUB&F4:EQUB&02:EQUB&01:EQUB&00:EQUB&40:EQUB&20:EQUB&10:EQUB&38
    EQUB&1C:EQUB&0D:EQUB&F9:EQUB&00:EQUB&80:EQUB&40:EQUB&10:EQUB&08
    EQUB&04:EQUB&03:EQUB&81:EQUB&C7:EQUB&7C:EQUB&40:EQUB&20:EQUB&10
    EQUB&04:EQUB&02:EQUB&01:EQUB&01:EQUB&C0:EQUB&E3:EQUB&DE:EQUB&10
    EQUB&08:EQUB&04:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&E0:EQUB&71
    EQUB&F7:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&40:EQUB&20:EQUB&10
    EQUB&0E:EQUB&07:EQUB&FD:EQUB&81:EQUB&00:EQUB&80:EQUB&40:EQUB&10
    EQUB&08:EQUB&04:EQUB&07:EQUB&03:EQUB&FF:EQUB&40:EQUB&40:EQUB&20
    EQUB&10:EQUB&04:EQUB&02:EQUB&01:EQUB&03:EQUB&81:EQUB&FF:EQUB&C0
    EQUB&10:EQUB&08:EQUB&06:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20
    EQUB&10:EQUB&07:EQUB&FF:EQUB&03:EQUB&80:EQUB&80:EQUB&40:EQUB&20
    EQUB&10:EQUB&08:EQUB&04:EQUB&05:EQUB&FF:EQUB&81:EQUB&C0:EQUB&20
    EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&03:EQUB&7F:EQUB&C0
    EQUB&E0:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&41
    EQUB&DF:EQUB&1C:EQUB&0E:EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40
    EQUB&20:EQUB&10:EQUB&F7:EQUB&8E:EQUB&07:EQUB&00:EQUB&80:EQUB&40
    EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&7D:EQUB&C7:EQUB&03:EQUB&80
    EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&3F:EQUB&60
    EQUB&70:EQUB&38:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00:EQUB&80
    EQUB&5F:EQUB&D0:EQUB&38:EQUB&1C:EQUB&02:EQUB&01:EQUB&00:EQUB&80
    EQUB&40:EQUB&20:EQUB&1F:EQUB&F0:EQUB&1C:EQUB&0F:EQUB&00:EQUB&80
    EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&07:EQUB&01:EQUB&FF:EQUB&C0
    EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&03:EQUB&81
    EQUB&7F:EQUB&E0:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01:EQUB&00
    EQUB&81:EQUB&C0:EQUB&DF:EQUB&F0:EQUB&04:EQUB&02:EQUB&01:EQUB&00
    EQUB&80:EQUB&40:EQUB&20:EQUB&1C:EQUB&77:EQUB&C7:EQUB&01:EQUB&00
    EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&0E:EQUB&3D:EQUB&E3
    EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&07
    EQUB&1F:EQUB&71:EQUB&C0:EQUB&10:EQUB&08:EQUB&04:EQUB&02:EQUB&01
    EQUB&00:EQUB&80:EQUB&7F:EQUB&D8:EQUB&1C:EQUB&04:EQUB&02:EQUB&01
    EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&3F:EQUB&F4:EQUB&0E:EQUB&01
    EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&1F:EQUB&FC
    EQUB&07:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04:EQUB&03
    EQUB&81:EQUB&C0:EQUB&7F:EQUB&A0:EQUB&10:EQUB&08:EQUB&04:EQUB&02
    EQUB&01:EQUB&01:EQUB&C0:EQUB&E0:EQUB&5F:EQUB&C8:EQUB&04:EQUB&02
    EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&E0:EQUB&70:EQUB&37:EQUB&E2
    EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&0E:EQUB&07
    EQUB&1D:EQUB&F0:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08:EQUB&04
    EQUB&07:EQUB&03:EQUB&8F:EQUB&78:EQUB&20:EQUB&10:EQUB&08:EQUB&04
    EQUB&02:EQUB&01:EQUB&03:EQUB&81:EQUB&C7:EQUB&DC:EQUB&08:EQUB&04
    EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&38:EQUB&1F:EQUB&F6
    EQUB&02:EQUB&01:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&1C
    EQUB&0F:EQUB&FD:EQUB&00:EQUB&80:EQUB&40:EQUB&20:EQUB&10:EQUB&08
    EQUB&04:EQUB&0E:EQUB&07:EQUB&FF:EQUB&00

.code_end

cands_17        = vision_map + 821
cands_89v       = cands_17 + 81
cand_count      = cands_17 + 162

SAVE "M.SUDOKU0", code_begin, code_end, safe_return
