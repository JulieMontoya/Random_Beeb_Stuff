scr_ptr         = &70
see_ptr         = &72
text_ptr        = &74

set_ptr         = &76

remainder       = &81
divisor         = &82
quotient        = &80

multiplier      = &80
preload         = &82
multiplicand    = &84
product         = &80

tempX           = &86
tempY           = &87
pixelX          = &88
pixelY          = &89
fix_pos         = &8A
var_pos         = &8B

digit           = &8D
cand_copy       = &8E

\  BASIC VARIABLES

bas_var_S       = &44C

\  MOS ENTRY POINTS

osasci          = &FFE3
osnewl          = &FFE7
oswrch          = &FFEE

\  ERROR CODES

E_NOT_ALLOWED   = 51
    

ORG &6000

.code_begin

.ext_reset_grid
    JMP reset_grid
.ext_set_digit
    JMP set_digit
.ext_set_pixel
    JMP set_pixel
.ext_clr_pixel
    JMP clr_pixel
.ext_show_seen
    JMP show_seen
.ext_test_solved
    JMP test_solved
.ext_test_candidate
    JMP test_candidate
.ext_eliminate_candidate
    JMP eliminate_candidate
.ext_disp_pos
    JMP disp_pos
.ext_disp_contents
    JMP disp_contents
.ext_get_see
    JMP get_see
.ext_clr_seen
    JMP clr_seen
.ext_elim_out
    JMP elim_out
.ext_reset_tally
    JMP reset_tally
.ext_update_tally
    JMP update_tally
.ext_show_instances
    JMP show_instances
.ext_get_set_cell
    JMP get_set_cell
.ext_set_set_cell
    JMP set_set_cell
.ext_clr_set_cell
    JMP clr_set_cell
.ext_show_set
    JMP show_set
.ext_tally_set
    JMP tally_set
.ext_fill_set
    JMP fill_set
.ext_elim_in
    JMP elim_in
.ext_elim_set
    JMP elim_set
    
\    .ext_write_digit
\        JMP write_digit
\    .ext_set_pmk
\        JMP set_pmk
\    .ext_clr_pmk
\        JMP clr_pmk
\    .ext_toggle_pmk
\        JMP toggle_pmk
\    .ext_calc_digit_pos
\        JMP calc_digit_pos
\    .ext_calc_pmk_pos
\        JMP calc_pmk_pos
\    .ext_divide_by_3
\        JMP divide_by_3
\    .ext_multiply
\        JMP mult16
\    .ext_set_digit_colour
\        JMP set_digit_colour
\    .ext_set_see
\        JMP set_see
\    .ext_clr_see
\        JMP clr_see
\    .ext_calc_see_pos
\        JMP calc_see_pos
    
.divide_by_3
    LDY #&C0
    STY divisor
.fast_divide
    LDY #0
    STY quotient
.fd1
    TAY                 \  Save remainder in Y
    SEC
    SBC divisor
    BCS fd2             \  Skip restore if subtraction succeeded
    TYA                 \  Undo subtraction
.fd2
    ROL quotient        \  Shift in carry bit
    LSR divisor         \  Try subtracting in next lower place
    BCC fd1             \  Keep going till 1 drops out of the end
    TAY                 \  Return remainder in Y
    LDA quotient
    RTS
    
.mult16
    LDA #0
    STA product+3
    STA product+2
.mult16_preload
    \  Begin by shifting the multiplier right so its lowest bit is already
    \  in the carry flag.
    LDY #17             \  one more than we need
    BNE _mult16_3      \  always branches; A = 0
._mult16_1
    BCC _mult16_2
    \  Add the multiplicand to the high word of the product
    CLC
    LDA product+2
    ADC multiplicand
    STA product+2
    LDA product+3
    ADC multiplicand+1
    STA product+3
    \  Shift the product right
._mult16_2
    ROR product+3
    ROR product+2
._mult16_3
    ROR product+1
    ROR product
    \  See if we need to go around again
    DEY
    BNE _mult16_1
    RTS
    
.set_mulcnd
    STA multiplicand
    LDA #0
    STA multiplicand+1
    RTS
    
.alt_calc_see_pos
    STX preload
    STY multiplier
    LDA #81
    STA multiplicand
    LDA #0
    STA multiplier+1
    STA preload+1
    STA multiplicand+1
    JSR mult16_preload
    LDA product
    LDX product+1
    RTS

\  CALCULATE SCREEN ADDRESS FROM DIGIT POSITION
\  ON ENTRY X, Y GIVE DIGIT POSITION
\  A IS PRESERVED 

.calc_digit_pos
    PHA
    STY scr_ptr             \  Place copy of Y co-ordinate in pointer
    LDA #0
    STA scr_ptr+1
    TYA                 \  Work with Y co-ordinate in A
    ASL  A
    ASL  A              \  Now A = Y * 4
    CLC                 \  No harm in making sure
    ADC scr_ptr         \  Add the copy we saved earlier
    STA scr_ptr         \  Now [scr_ptr] = Y * 5 ; max. value = 40
    ASL scr_ptr
    ASL scr_ptr
    ASL scr_ptr         \  max. value = 320 -- may set C
    ROL scr_ptr+1
    ASL scr_ptr
    ROL scr_ptr+1       \  Now [scr_ptr, scr_ptr+1] = Y * 80
    TXA                 \  Work with X co-ordinate in A
    ASL  A
    ASL  A              \  Now A = X * 4
    CLC
    ADC scr_ptr
    STA scr_ptr
    BCC _cdp1           \  Skip if no carry
    INC scr_ptr+1       \  Now [scr_ptr, scr_ptr+1] = Y * 80 + X * 4
._cdp1
    CLC                 \  Add beginning of screen to [scr_ptr, scr_ptr+1]
    LDA #&7C
    ADC scr_ptr+1
    STA scr_ptr+1
    PLA                 \  Retrieve the value saved earlier
.safe_return
    RTS
    
\  WRITE DIGIT A IN POSITION (X, Y)
\
\  On entry X => X co-ordinate in main grid
\           Y => Y co-ordinate in main grid
\           A = Digit to write; 0 erases digit

.write_digit
    JSR calc_digit_pos
    ASL  A
    ASL  A              \  Now A = digit * 4
    TAX                 \  This is index into table.
    LDY #1
    JSR digit_row
    JSR digit_row2
    LDY #41
    JSR digit_row
.digit_row2
    LDA #&20
    STA (scr_ptr),Y
    RTS
.digit_row
    JSR digit_row1
.digit_row1
    LDA digit_patt,X
    INX
    STA (scr_ptr),Y
    INY
    RTS
    
\  CALCULATE SCREEN ADDRESS FOR PENCIL MARK POSITION
\  Pencil marks are a 3*3 grid of dots
\
\   1  2  3
\   4  5  6
\   7  8  9
\
\  On entry X => X co-ordinate in main grid
\           Y => Y co-ordinate in main grid

.calc_pmk_pos
    JSR calc_digit_pos
    STA &72             \  Save copy of A
    ASL  A              \  Multiply by 2
    ADC &72             \  Add copy to get 3 * digit
    ASL  A              \  Double to get 6 * digit
    TAX
    LDY #1
    RTS

\  SET A PENCIL MARK
    
.set_pmk
    JSR calc_pmk_pos
    JSR set_row
    LDY #41             \  Beginning of second row
.set_row                \  Set row of pixel pattern for digit
    JSR set_row1
    JSR set_row1
.set_row1
    LDA (scr_ptr),Y
    ORA pmk_patt,X
    JMP pmk_write

\  CLEAR A PENCIL MARK

.clr_pmk
    JSR calc_pmk_pos
    JSR clr_row
    LDY #41             \  Beginning of second row
.clr_row                \  Unset row of pixel pattern for digit
    JSR clr_row1
    JSR clr_row1
.clr_row1
    LDA (scr_ptr),Y
    ORA pmk_patt,X      \  Setting and inverting just the bit we want is
    EOR pmk_patt,X      \  quicker than inverting it to create a mask
    JMP pmk_write
    
\  TOGGLE A PENCIL MARK ON <-> OFF

.toggle_pmk
    JSR calc_pmk_pos
    JSR toggle_row
    LDY #41             \  Beginning of second row
.toggle_row             \  EOR pixel pattern row for digit with screen
    JSR toggle_row1
    JSR toggle_row1
.toggle_row1
    LDA (scr_ptr),Y
    EOR pmk_patt,X
.pmk_write
    INX                 \  Next position in pattern
    STA (scr_ptr),Y
    INY                 \  Next position on screen
    RTS

.set_digit_colour
    JSR calc_digit_pos
    AND #&07
    BNE _sdc_not0
    LDA #7
._sdc_not0
    ORA #&90            \  Set graphics colour
    LDY #0
    STA (scr_ptr), Y
    LDY #40
    STA (scr_ptr), Y
    RTS

.calc_see_pos
    STX preload         \  Begin with X in preload ...
    STY multiplier      \  ... Y in multiplier ...
    LDA #81             \  ... 81 in multiplicand
    STA multiplicand
    LDA #0              \  All high bytes are 0 
    STA multiplier+1
    STA preload+1
    STA multiplicand+1
    JSR mult16_preload
    LDA product
    AND #&07            \  Equivalent to MOD 8
    TAX                 \  Now X holds position MOD 8
    LSR product+1
    ROR product
    LSR product+1
    ROR product
    LSR product+1
    ROR product         \  Equivalent to DIV 8
    CLC
    LDA product
    ADC #see_table MOD256
    STA see_ptr
    LDA product+1
    ADC #see_table DIV256
    STA see_ptr+1
    LDY #0
    LDA (see_ptr), Y
    RTS
    
.get_see
    JSR calc_see_pos
    AND bits_HL, X
    RTS
    
.set_see
    JSR calc_see_pos
    ORA bits_HL, X
    BNE _clr_see1       \  Always branches
.clr_see
    JSR calc_see_pos
    ORA bits_HL, X      \  Set it
    EOR bits_HL, X      \  Toggle it
._clr_see1
    STA (see_ptr), Y
    RTS

.set_pixel
    JSR get_pixel_pos
    ORA (scr_ptr), Y
    STA (scr_ptr), Y
    RTS
.clr_pixel
    JSR get_pixel_pos
    EOR #&FF
    AND (scr_ptr), Y
    STA (scr_ptr), Y
    RTS
    
\  GET PIXEL POSITION
\
\  Expects X = 0 .. 77 and Y = 0 .. 74  (NB: 0 is at top!)
\
\  On return, scr_ptr points to screen location
\             A = bit mask for pixel within character cell

.get_pixel_pos
    TYA                 \  Prepare to divide Y co-ordinate by 3
    LDY #0              \  Clear high byte of screen pointer
    STY scr_ptr+1
    JSR divide_by_3     \  Now A = answer, Y = remainder
    STA scr_ptr         \  Save a copy of (Y DIV 3)
    ASL A
    ASL A
    CLC
    ADC scr_ptr         \  Now [scr_ptr] = 5 * (Y DIV 3) ; max. = 120
    STA scr_ptr
    ASL scr_ptr         \  Max. value = 240
    ASL scr_ptr         \  This one might generate a carry
    ROL scr_ptr+1
    ASL scr_ptr
    ROL scr_ptr+1       \  Now [scr_ptr] = 40 * (Y DIV 3) ; max. = 960
    TXA                 \  X co-ordinate 0..77
    LSR A               \  Halve it, shifting LSB into carry
    PHP                 \  Save carry flag for later
    SEC                 \  Add extra 1 to skip graphics colour ctrl code
    ADC scr_ptr         \  Add horizontal character position
    STA scr_ptr         \  Now [scr_ptr] = 40 * (Y DIV 3) + (X DIV 2) + 1
    LDA scr_ptr+1
    ADC #&7C            \  Add high byte of address of start of screen
    STA scr_ptr+1
    PLP                 \  Retrieve carry flag => old lowest bit of X
    BCC _gpp_lhs        \  Skip for a pixel on the left-hand side
._gpp_rhs
    INY
    INY
    INY                 \  Now we point to right-hand pixel value
._gpp_lhs
    LDA lh_pixels, Y    \  
    LDY #0
    RTS

.lh_pixels
    EQUB &01:EQUB &04:EQUB &10
.rh_pixels
    EQUB &02:EQUB &08:EQUB &40

.show_seen
    STX fix_pos
    STY pixelY
    LDA #0
    STA var_pos
._ss_row
    LDA #68
    STA pixelX
._ss_col
    LDX fix_pos
    LDY var_pos
    JSR get_see
    PHP                 \  Save Z flag for later
    LDX pixelX
    LDY pixelY
    PLP                 \  Retrieve Z flag
    BEQ _ss_0
    JSR set_pixel
    BNE _ss_next        \  Will always branch
._ss_0
    JSR clr_pixel
._ss_next
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #77
    BCC _ss_col
    INC pixelY
    LDA var_pos
    CMP #81
    BCC _ss_row
    RTS

.clr_seen
    LDX #68
    JSR get_pixel_pos   \  Now [scr_ptr] is set
    LDX #14    
.cs_char
    LDA map_pos, X
    TAY
    LDA #32
    STA (scr_ptr), Y
    DEX
    BPL cs_char
    RTS

\  RESET THE GRID TO COMPLETELY EMPTY
\
\  BIT PATTERN FOR EACH CELL IN THE GRID IS INITIALLY AS FOLLOWS;
\
\  cands_17, X          cands_89v, X
\           01111111            11000000
\           ||||||||            ||  ||||
\           |1|3|5|7            |9  `--'
\           | 2 4 6             8   value
\      solved

.reset_grid
    LDX #0
._rsg_0
    LDA #&7F
    STA cands_17, X
    LDA #&C0
    STA cands_89v, X
    INX
    CPX #81
    BCC _rsg_0
    RTS
    
\  TEST WHETHER A CANDIDATE IS ALLOWED IN A CELL
\  X => CELL TO TEST
\  A => CANDIDATE TO TEST FOR

.test_candidate
    TAY                 \  Candidate for which we are testing
.test_cand_Y
    CPY #8              \  See which byte candidate belongs to
    BCS _tc_89
._tc_17
    LDA cands_17, X     \  Byte with candidates 1-7
    AND bits_HL, Y      \  AND with bit for candidate
    RTS
._tc_89
    LDA cands_89v, X    \  Byte with candidates 8-9 and value
    AND bits_HL-8, Y    \  AND with bit for candidate
    RTS

\  ELIMINATE A CANDIDATE FROM A CELL
\  X => CELL TO ELIMINATE FROM
\  A => CANDIDATE TO ELIMINATE

.eliminate_candidate
    CLV                 \  V=0 => not naked single
    TAY                 \  Save the candidate
    LDA cands_17, X
    BMI _ec_never_set   \  Exit if already solved
    CPY #8
    BCS _ec_89
._ec_17
    AND bits_HL, Y
    BEQ _ec_never_set   \  Exit if candidate was never allowed
    LDA cands_17, X     \  Byte with candidates 1-7
    ORA bits_HL, Y
    EOR bits_HL, Y
    STA cands_17, X
    JMP _ec_done
._ec_89
    LDA cands_89v, X    \  Byte with candidates 8-9
    AND bits_HL-8, Y
    BEQ _ec_never_set
    LDA cands_89v, X    \  Byte with candidates 8-9
    ORA bits_HL-8, Y
    EOR bits_HL-8, Y
    STA cands_89v, X
._ec_done
    CLV                 \  V=0 => not naked single
    CLC                 \  C=0 => candidate successfully eliminated
    
    \  MAKE SURE SOME CANDIDATES ARE STILL ALLOWED.
    \  IF ONLY ONE REMAINS -- CONSIDER CELL SOLVED
    
._ec_count_cands
    LDA #0
    STA multiplier      \  Use this to count allowed digits
    STA preload         \  This is initially 0
    LDA #&40
    STA multiplier+1    \  Use this to hold bit mask
    LDY #1              \  Digit we are testing for
._ctc_b1
    LDA cands_17, X     \  Byte with candidates 1-7
    BIT multiplier+1
    BEQ _ctc_b1_0
    INC multiplier
    STY preload         \  Keep track of highest allowed candidate
._ctc_b1_0
    INY                 \  
    LSR multiplier+1
    BCC _ctc_b1         \  Keep going until 1 shifts out
    
    \  Now we need to test for candidates 8 and 9
    
    LDA cands_89v, X
    BPL _ctc_b2_0x      \  Test bit 7 => 8 allowed
    INC multiplier
    STY preload
._ctc_b2_0x
    INY
    BIT bits_HL+1       \  Test bit 6 => 9 allowed
    BEQ _ctc_b2_x0
    INC multiplier
    STY preload
._ctc_b2_x0
    LDA multiplier
    CMP #1
    BNE _ctc_not_naked
._ctc_naked
    \  ONLY ONE POSSIBLE CANDIDATE REMAINS = NAKED SINGLE!
    \  DIGIT VALUE MUST BE IN preload
    LDA #&80
    STA cands_17, X     \  Set "solved" bit
    \LDA cands_89v, X
    \ORA preload
    LDA preload
    STA cands_89v, X    \  Store cell value
    LDY preload
    BIT _ctc_rts        \  This will set V=1 => cell now solved
    RTS
._ctc_not_naked
    CLV                 \  V=0 => not naked single
    CLC                 \  C=0 => successful elimination, A is count
._ctc_rts
    RTS
    
._ec_never_set
    SEC                 \  C=1 => candidate was never allowed
    RTS

\  SET A DIGIT TO A DEFINITE VALUE

.set_digit
    JSR test_candidate
    BNE _sd_1
    BRK
    EQUB E_NOT_ALLOWED
    EQUS "Not allowed"
    BRK
._sd_1
    LDA #&80
    STA cands_17, X
    TYA
    STA cands_89v, X
    RTS

.conv_xy
    TAX
.conv_xyX
    LDA xy_coords, X
    TAX
    JSR lsra4
    TAY
    TXA
    AND #&0F
    TAX
    RTS
    
.lsra4
    LSR A
    LSR A
    LSR A
    LSR A
    RTS

\  CONVERT A CELL POSITION 0..80 TO A HUMAN-READABLE ROW AND COLUMN
\  E.G.  0 => R1C1, 12 => R2C4, 40 => R5C5, 63 => R7C1, 80 => R9C9
\  POSITION SHOULD BE IN X
\  PRESERVES A, X AND Y
    
.disp_pos
    PHA
    TYA
    PHA
    TXA
    PHA
    JSR conv_xyX
    LDA #&52            \  "R"
    JSR oswrch
    TYA
    SEC                 \  display row number starting from 1
    ADC #&30            \  ASCII code for 0
    JSR oswrch
    LDA #&43            \  "C"
    JSR oswrch
    TXA
    SEC                 \  display column number starting from 1
    ADC #&30
    JSR oswrch
    PLA
    TAX
    PLA
    TAY
    PLA
    RTS

.disp_contents
    PHA
    TYA
    PHA
    TXA
    PHA
    LDA digit
    PHA
    LDA cands_17, X
    STA cand_copy
    LDA cands_89v, X
    STA cand_copy+1
    JSR conv_xyX        \  Now X, Y hold co-ords
    BIT cand_copy       \  Bit 7 = 1 => solved
    BPL _dcc_pmark
._dcc_digit
    LDA cand_copy+1     \  Solved digit value
    JSR write_digit
    JMP _dcc_end
._dcc_pmark
    STX tempX           \  Save X co-ordinate
    STY tempY           \  Save Y co-ordinate
    JSR asl_cand_copy   \  Avoid a useless first trip around the loop
    LDA #1
    STA digit
._dcc_test
    JSR asl_cand_copy
    BCC _dcc_pmk_0
    JSR set_pmk
    JMP _dcc_next
._dcc_pmk_0
    JSR clr_pmk
._dcc_next
    INC digit
    LDA digit
    LDX tempX           \  Retrieve X co-ordinate
    LDY tempY           \  Retrieve Y co-ordinate
    CMP #10
    BCC _dcc_test       \  Test next candidate
._dcc_end
    PLA
    STA digit
    PLA
    TAX
    PLA
    TAY
    PLA
    RTS

.reset_tally
    LDX #9
    LDA #0
._ccc_1
    STA cand_count, X
    DEX
    BPL _ccc_1
    RTS

.update_tally
    LDA cands_17, X
    STA cand_copy       \  Make copy of allowed candidates
    BPL _udt_not_solved
    INC cand_count      \  Count of "zeros" is count of solved digits
    CLC                 \  C=0 => was already solved
    RTS
._udt_not_solved
    LDA cands_89v, X
    STA cand_copy+1
    LDX #0              \  First pass will do nothing, but the saving in
._udt_test_digit        \  cycles is hardly worth the extra bytes.
    JSR asl_cand_copy   \  Now C=1 => candidate was allowed
    BCC _udt_not_allowed
    INC cand_count, X   \  Increase count of allowed digit
._udt_not_allowed
    INX
    CPX #10
    BCC _udt_test_digit
    RTS                 \  With C=1
.asl_cand_copy
    ASL cand_copy+1
    ROL cand_copy
    RTS
    
\  TEST WHETHER A CANDIDATE IS ALLOWED IN A CELL
\  X => CELL TO TEST
\  ON RETURN A=0 => NOT SOLVED
\            A>0 => CELL VALUE

.test_solved
    TAY                 \  Save the candidate
    LDA cands_17, X     \  Bit 7=1 => is solved
    BMI _tsv_solved
    LDA #0              \  Z=1; will cause BEQ to branch
    RTS
._tsv_solved
    LDA cands_89v, X    \  Contains solved value
    RTS
    
\  ELIMINATE CANDIDATES FROM CELLS, WORKING OUTWARDS
\  THIS IS not SAFELY RE-ENTRANT, SO WE CAN't CHASE UP NAKED SINGLES

\  ORIGINAL BASIC
\
\ 5100DEFPROCman_elim_out(I%,D%)
\ 5110LOCALJ%,E%
\ 5112PRINT"Showing contents of ";:PROCdisp_pos(I%):PRINT
\ 5114PROCdisp_cont(I%)
\ 5120FORJ%=0TO80
\ 5130IFJ%=I%GOTO5190
\ 5140IFFNsee(I%,J%)=0GOTO5190
\ 5150IFFNsolved(J%)GOTO5190
\ 5160E%=FNelim_cand(J%,D%)
\ 5170IF(E%AND&1000000)=0PRINT;D%;" in ";:PROCdisp_pos(I%):PRINT" sees ";:PROCdisp_pos(J%):PRINT
\ 5180PROCdisp_cont(J%)
\ 5190NEXT
\ 5200ENDPROC
    
.elim_out

\ 5100DEFPROCman_elim_out(I%,D%)
\ 5110LOCALJ%,E%

    STA digit
    LDA fix_pos
    PHA
    LDA var_pos
    PHA

\ 5112PRINT"Showing contents of ";:PROCdisp_pos(I%):PRINT
\ 5114PROCdisp_cont(I%)

    STX fix_pos
    LDY #66
    JSR show_seen
    LDX fix_pos
    JSR disp_contents

\ 5120FORJ%=0TO80

    LDX #0
    STX var_pos
._neo_test

\ 5130IFJ%=I%GOTO5190

    CPX fix_pos
    BEQ _neo_no_elim    \  No elimination from same cell
    
\ 5140IFFNsee(I%,J%)=0GOTO5190

    LDY fix_pos
    JSR get_see
    BEQ _neo_no_elim    \  No elimination if does not see

\ 5150IFFNsolved(J%)GOTO5190
\ 5160E%=FNelim_cand(J%,D%)

    LDX var_pos
    LDA digit
    JSR eliminate_candidate
    
    BCS _neo_no_elim    \  No elimination if never allowed

    BVC _neo_not_naked
\    TYA
\    ORA #&30
\    PHA
\    
\    JSR say
\    EQUS "Nkd Sgl "
\    BRK
\    LDX var_pos
\    JSR disp_pos
\    LDA#61
\    JSR oswrch
\    
\    PLA
\    JSR oswrch
\    JSR osnewl
\    
\    CLC
\    
    BRK
    EQUB 56
    EQUS "Naked single"
    BRK
    
\ 5170IF(E%AND&1000000)=0PRINT;D%;" in ";:PROCdisp_pos(I%):PRINT" sees ";:PROCdisp_pos(J%):PRINT

._neo_not_naked
    \LDA digit
    LDX fix_pos
    LDA cands_89v, X
    ADC #48             \  We know C=0 here
    JSR oswrch
    JSR say
    EQUS " in "
    BRK
    LDX fix_pos
    JSR disp_pos
    JSR say
    EQUS " sees "
    BRK
    LDX var_pos
    JSR disp_pos
    JSR osnewl

\ 5180PROCdisp_cont(J%)

    LDX var_pos
    JSR disp_contents

\ 5190NEXT

._neo_no_elim
    INC var_pos
    LDX var_pos
    CPX #81
    BCC _neo_test

\ 5200ENDPROC

    PLA
    STA var_pos
    PLA
    STA fix_pos
    RTS
    
\  ELIMINATE CANDIDATES FROM A CELL, WORKING INWARDS

    
.elim_in
    LDA fix_pos         \  Save fixed and variable positions
    PHA                 \  (which we are going to stomp on)
    LDA var_pos
    PHA

    STX fix_pos
    LDY #66
    JSR show_seen
    LDX #0
    STX var_pos
    
._nei_test
    CPX fix_pos         \  Skip if same position
    BEQ _nei_no_elim
    LDY fix_pos
    JSR get_see
    BEQ _nei_no_elim    \  No elimination if does not see
    LDX var_pos
    JSR test_solved     \  See if digit is solved
    BEQ _nei_no_elim
    
    STA digit           \  Remember digit for later
    LDX fix_pos
    JSR eliminate_candidate
    BCS _nei_no_elim
    JSR _nei_elim       \  Display message about elimination
    
    LDX var_pos
    BVC _nei_not_naked
    
    JSR say
    EQUS "Naked single"
    BRK
    
    LDA #80             \  Jump to end of grid
    STA var_pos
    
._nei_not_naked
    LDX fix_pos
    JSR disp_contents
    
._nei_no_elim
    INC var_pos
    LDX var_pos
    CPX #81
    BCC _nei_test
    
    PLA                 \  Restore the previous positions
    STA var_pos
    PLA
    STA fix_pos
    RTS
    
._nei_elim
    PHP
    PHA
    TYA
    PHA
    TXA
    PHA
    
    LDX fix_pos         \  Display fixed position
    JSR disp_pos
    JSR say
    EQUS " sees "
    BRK
    LDA digit           \  Display digit in seen cell
    ORA #&30
    JSR oswrch
    JSR say
    EQUS " in "
    BRK
    LDX var_pos         \  Display variable position
    JSR disp_pos
    JSR osnewl
    
    PLA
    TAX
    PLA
    TAY
    PLA
    PLP
    RTS
    


\  SHOW ALL INSTANCES OF A CANDIDATE

.show_instances
    STX digit
    STY pixelY
    LDA #0
    STA var_pos
._shi_row
    LDA #68
    STA pixelX
._shi_col
    LDX var_pos
    JSR test_solved
    BNE _shi_0
    LDY digit
    JSR test_cand_Y
    BEQ _shi_0
    LDX pixelX
    LDY pixelY
    JSR set_pixel
    BNE _shi_next       \  Will always branch
._shi_0
    LDX pixelX
    LDY pixelY
    JSR clr_pixel
._shi_next
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #77
    BCC _shi_col
    INC pixelY
    LDA var_pos
    CMP #81
    BCC _shi_row
    RTS

\  CONVERT A BIT OFFSET IN Y, TO A BYTE OFFSET IN Y AND A SUB-OFFSET
\  TO A BIT WITHIN THAT BYTE IN X
    
.calc_set_ofs
    TYA                 \  Copy Y to accumulator
    TAX                 \  Also make a copy in X
    LSR A               \  Divide by 8 ...
    LSR A
    LSR A
    TAY                 \  ... and store in Y
    TXA                 \  Retrieve copy
    AND #7              \  Get remainder modulo 8 ...
    TAX                 \  ... and store in X
    RTS
    
.get_set_cell
    JSR calc_set_ofs
    LDA (set_ptr), Y
    AND bits_HL, X      \  Z=0 => bit was 1
    RTS

.set_set_cell
    JSR calc_set_ofs
    LDA (set_ptr), Y
    ORA bits_HL, X
    STA (set_ptr), Y
    RTS

.clr_set_cell
    JSR calc_set_ofs
    LDA (set_ptr), Y
    ORA bits_HL, X      \  force it to 1 ...
    EOR bits_HL, X      \  ... then invert it
    STA (set_ptr), Y
    RTS

\  SHOW THE IN/OUT STATUS OF A SET OF GRID SQUARES
\  ON ENTRY Y = VERTICAL POSITION
\           set-ptr,set_ptr+1 => SET TO DISPLAY

.show_set
    STY pixelY
    LDA #0
    STA var_pos
._shs_row
    LDA #68
    STA pixelX
._shs_col
    LDY var_pos
    JSR get_set_cell
    PHP                 \  Save Z flag for later
    LDX pixelX
    LDY pixelY
    PLP                 \  Retrieve Z flag
    BEQ _shs_0
    JSR set_pixel
    BNE _shs_next       \  Will always branch
._shs_0
    JSR clr_pixel
._shs_next
    INC var_pos
    INC pixelX
    LDA pixelX
    CMP #77
    BCC _shs_col
    INC pixelY
    LDA var_pos
    CMP #81
    BCC _shs_row
    RTS

\  TALLY UP THE POSSIBLE CANDIDATES FOR THE CELLS IN A SET
\  ON RETURN; cand_count     => SOLVED CELLS
\             cand_count + 1 => POSSIBLE 1S
\             cand_count + 2 => POSSIBLE 2S
\               ...
\             cand_count + 9 => POSSIBLE 9S
\  SOLVED CELLS DO NOT COUNT TOWARDS CANDIDATE COUNTS!
\  IF A DIGIT CAN GO IN ONLY ONE CELL, WE NEED TO PUT
\  IT THERE!

.tally_set
    JSR reset_tally     \  This will leave 0 in A
    STA var_pos
._tys_pos
    LDY var_pos
    JSR get_set_cell    \  See if cell is in set
    BEQ _tys_not_in     \  Skip if not in set
    LDX var_pos
    JSR update_tally
._tys_not_in
    INC var_pos
    LDA var_pos
    CMP #81
    BCC _tys_pos
    RTS

.fill_set
    STA digit
    LDA #0
    STA var_pos
._fis_pos
    LDX var_pos
    JSR get_set_cell    \  See if cell is in set
    BEQ _fis_not_in     \  Skip if not in set
    LDX var_pos
    LDA digit
    JSR test_candidate
    BEQ _fis_not_in

    LDA digit
    CLC
    ADC #48
    JSR oswrch
    JSR say
    EQUS " can only go in "
    BRK
    LDX var_pos
    JSR disp_pos
    LDA #46
    JSR oswrch
    JSR osnewl
    
    LDA digit
    LDX var_pos
    JSR set_digit
    JSR disp_contents
    JSR elim_out
._fis_not_in
    INC var_pos
    LDA var_pos
    CMP #81
    BCC _fis_pos
    RTS

.elim_set
    LDA #0
    STA var_pos
._els_pos
    LDY var_pos
    JSR get_set_cell    \  See if cell is in set
    BEQ _els_not_in     \  Skip if not in set
    
    LDX var_pos
    JSR test_solved
    BEQ _els_not_solved
.els_solved
    LDA digit
    JSR elim_out        \  Eliminate candidates it sees
    JMP _els_not_in
._els_not_solved
    JSR elim_in         \  Eliminate anything seen as candidate
    LDX var_pos
._els_not_in
    INC var_pos
    LDX var_pos
    CPX #81
    BCC _els_pos
    RTS

    
.say
    PHP                 \  Stash everything on the 6502 stack
    PHA
    TYA
    PHA
    TXA
    PHA                 \  Now there are 4 bytes on top of return addr-1
    TSX                 \  &101 + stack pointer => most recently pushed
    LDA &105, X
    STA text_ptr        \  Low byte of return address-1
    LDA &106, X
    STA text_ptr+1      \  High byte of return address-1
    LDY #1              \  Start one ahead of address on stack
._ss_say_1
    LDA (text_ptr), Y
    BEQ _ss_say_2       \  Don't send CHR$(0)
    INY
    JSR osasci
    CMP #&20            \  Stop printing after any control char
    BCS _ss_say_1
    DEY                 \  We no longer need to compensate for address-1
._ss_say_2
    TYA                 \  Overwrite old return address with new value
    CLC                 \  adjusted by length of string we just printed
    ADC text_ptr
    TSX
    STA &105, X
    LDA text_ptr+1
    ADC #0
    STA &106, X
    PLA                 \  Retrieve the values we stashed earlier
    TAX
    PLA
    TAY
    PLA
    PLP
    RTS                 \  To the modified address

    
ALIGN &100

\  DIGIT PATTERNS
\
\  EACH DIGIT HAS 4 BYTES WHICH GIVE THE CHARACTER CODES FOR ITS GLYPH
\  IN EACH OF 2 ROWS OF 2 COLUMNS.  A THIRD, EMPTY COLUMN WILL BE ADDED
\  WHEN IT IS WRITTEN TO THE SCREEN.

.digit_patt
    EQUD &20202020
    EQUD &25203528
    EQUD &2C2D7B73
    EQUD &2E2C7B73
    EQUD &2A207A75
    EQUD &2E2C7377
    EQUD &2E2D7377
    EQUD &2A206B27
    EQUD &2E2D7B77
    EQUD &2E2C7B77
    \  digit "10" is underscore for cursor
    EQUD &70702020

\  PENCIL MARK PATTERNS
\
\  EACH DIGIT HAS 6 BYTES WHICH GIVE THE PIXEL VALUES IN EACH OF 2 ROWS
\  OF 3 COLUMNS.

.pmk_patt
    EQUW &0000:EQUD &00000000
    EQUW &0001:EQUD &00000000
    EQUW &0100:EQUD &00000000
    EQUW &0000:EQUD &00000001
    EQUW &0010:EQUD &00000000
    EQUW &1000:EQUD &00000000
    EQUW &0000:EQUD &00000010
    EQUW &0000:EQUD &00000400
    EQUW &0000:EQUD &00040000
    EQUW &0000:EQUD &04000000

\  X, Y CO-ORDINATES FOR GRID POSITIONS
\
\  HIGH NYBBLE = Y CO-ORDINATE
\  LOW NYBBLE  = X CO-ORDINATE

.xy_coords
    EQUD &03020100:EQUD &07060504:EQUB &08
    EQUD &13121110:EQUD &17161514:EQUB &18
    EQUD &23222120:EQUD &27262524:EQUB &28
    EQUD &33323130:EQUD &37363534:EQUB &38
    EQUD &43424140:EQUD &47464544:EQUB &48
    EQUD &53525150:EQUD &57565554:EQUB &58
    EQUD &63626160:EQUD &67666564:EQUB &68
    EQUD &73727170:EQUD &77767574:EQUB &78
    EQUD &83828180:EQUD &87868584:EQUB &88

.boxes
    EQUD &01000000:EQUD &02020101:EQUB &02
    EQUD &01000000:EQUD &02020101:EQUB &02
    EQUD &01000000:EQUD &02020101:EQUB &02
    EQUD &04030303:EQUD &05050404:EQUB &05
    EQUD &04030303:EQUD &05050404:EQUB &05
    EQUD &04030303:EQUD &05050404:EQUB &05
    EQUD &07060606:EQUD &08080707:EQUB &08
    EQUD &07060606:EQUD &08080707:EQUB &08
    EQUD &07060606:EQUD &08080707:EQUB &08

.bits_HL
    EQUD &10204080:EQUD &01020408
    
.map_pos
    EQUB 84:EQUB 83:EQUB 82:EQUB 81:EQUB 80
    EQUB 44:EQUB 43:EQUB 42:EQUB 41:EQUB 40
    EQUB 4:EQUB 3:EQUB 2:EQUB 1:EQUB 0
    
ORG &7680

.group_map
    BRK

ORG &7800

.see_table

    BRK
.code_end

cands_17        = see_table + 821
cands_89v       = cands_17 + 81
cand_count      = cands_17 + 162

SAVE "M.SUDOKU0", code_begin, code_end, safe_return

PRINT "group_map=",~group_map
PRINT "see_table=",~see_table
PRINT "cands_17=",~cands_17
PRINT "cands_89v=",~cands_89v
PRINT "cand_count=",~cand_count
